<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PAVE Scenario Generation</title>
  <link rel="icon" href="../images/manulife_logo.jpg" type="image/jpeg">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
</head>

<body>
  <div style="width: 550px;"
    class="h-screen bg-gray-50 border-r border-gray-200 p-0 flex flex-col overflow-y-auto overscroll-contain">
    <div class="items-center px-4 py-5 mb-6 w-full" style="background-color: #16a34a;">
      <div style="display: flex; align-items: center;">
        <a href="/index.html">
          <img src="../images/manulife_logo.jpg" alt="Manulife Logo" class="h-10 w-auto mr-4" />
        </a>
        <h1 class="text-xl font-semibold text-white">PAVE Scenario Generation</h1>
        <p style="font-size: 12px; color: white; margin-top: 4px; margin-left: 25px;">
          <a href="/userguides/PAVE%20Scenario%20Generation%20User%20Guide.pdf" target="_blank" class="white-button">
            User Guide
          </a>
        </p>
      </div>
      <p id="pave-version" style="font-size: 14px; color: white; margin-left: 20px; margin-top: 10px;"></p>
    </div>

    <div class="ml-6 mr-6">
      <!--Valuation Date-->
      <h3 class="quote-heading">Valuation Date</h3>
      <div>
        <div class="flex mb-4 gap-2 items-center">
          <input type="text" id="curveDate" placeholder="YYYY-MM-DD"
            class="w-40 rounded-md bg-white h-8 px-2 py-1 text-sm text-gray-900 shadow-xs ring-1 ring-gray-300 ring-inset hover:bg-gray-50 focus:outline-none" />
        </div>
      </div>

      <!-- Curve Type -->
      <div class="mb-6">
        <label for="curveSource">
          <span class="quote-heading">Curve Class</span>
          <select name="curveSource" id="curveSource" onchange="updateCurveTypes()"
            class="mt-0.5 mb- w-auto rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-00 shadow-xs ring-1 ring-gray-300 ring-inset hover:bg-gray-50">
            <option value="Findur">Findur Derivative Valuation Curves</option>
            <option value="ALM">ALM Customized Curves</option>
          </select>
        </label>
        <div id="curveTypeContainer" class="mt-2 space-y-1"></div>
      </div>

      <div id="curveControls">
        <div class="mb-6">
          <label class="quote-heading mt-4">Select Curve Group</label>
          <div class="relative text-gray-600 mb-4">
            <input type="search" id="curveSearch" placeholder="Search"
              class="bg-white h-8 px-5 pr-10 rounded-md text-sm w-full focus:outline-none ring-1 ring-gray-300 ring-inset hover:bg-gray-50" />
            <button type="submit" class="absolute right-0 top-0 mt-3 mr-4">
              <svg class="h-4 w-4 fill-current text-gray-500" xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 56.966 56.966">
                <path4.761,0,9.298-1.436,13.177-4.162l13.661,14.208c0.571,0.593,1.339,0.92,2.162,0.92
                  c0.779,0,1.518-0.297,2.079-0.837C56.255,54.982,56.293,53.08,55.146,51.887z
                  M23.984,6c9.374,0,17,7.626,17,17s-7.626,17-17,17 s-17-7.626-17-17S14.61,6,23.984,6z" />
              </svg>
            </button>
          </div>

          <!-- Dropdown menu of curves -->
          <select id="curveSubsetSelect" multiple size="10"
            class="w-full min-w-full rounded border-gray-300 shadow-sm text-sm h-40"
            style="border: 3px solid #16a34a;"></select>

          <button onclick="addCurveToSubset()" class="mt-2 w-full green-button">Add Curve</button>

          <!-- Selected Curves -->
          <div class="mt-4">
            <h3 class="quote-heading">Selected Curves: </h3>
            <h3 id="selectedCurveList" class="quote-heading"></h3>

            <div class="flex gap-2 mt-4 mb-2">
              <button onclick="getQuotesData()" class="flex-1 w-auto green-button text-gray-700 text-sm py-2 rounded">
                Get Quotes Data
              </button>
              <button id="resetCurveGroup" class="gray-button" onclick="resetCurveGroup()">Reset</button>
            </div>
            <div id="loadingMessage" class="text-green-600 text-sm mt-1 hidden">Getting data...</div>

            <!--Displays user's selected curves for viewing definition and editing quotes-->
            <div id="selectedCurves" class="space-y-2 mt-4"></div>
          </div>
        </div>

        <div id="shockOptions" style="display: block;">
          <div id="standardShock" style="display: block;">
            <!-- Shock All Button -->
            <button onclick="shockAll()" class="green-button mb-2" style="min-width: 150px;">Shock All</button>

            <!-- Advanced Settings Toggle -->
            <div>
              <span id="advancedToggle" style="color: rgb(143, 143, 143); cursor: pointer;"
                onclick="toggleAdvancedSettings()">
                Advanced Settings ▼
              </span>
            </div>

            <!-- Advanced Settings Section -->
            <div id="advancedSettings"
              style="display: none; margin-top: 12px; padding: 10px; border: 3px solid rgb(224, 224, 224); width: auto;">
              <h3 class="quote-heading" style="color: rgb(143, 143, 143);">Shock By</h3>

              <!-- Shock By Curve Type Option -->
              <div id="shockCurveTypeContainer" style="display: flex; align-items: center; margin-bottom: 12px;">
                <label style="min-width: 120px; color: rgb(143, 143, 143);">
                  <input type="radio" name="shockBy" value="type" onchange="handleShockByChange()"> Curve Type
                </label>
                <div id="curveTypeSection" style="display: none; margin-left: 12px;">
                  <label for="curveTypeSelect" style="margin-right: 8px; color: rgb(143, 143, 143);">Select
                    Type:</label>
                  <select id="curveTypeSelect" class="rounded-dropdown" style="color: rgb(143, 143, 143);"
                    onchange="proceedToScenario()">
                    <option value="Bond">Bond</option>
                    <option value="YieldCurve">YieldCurve</option>
                  </select>
                </div>
              </div>

              <!-- Shock By Curve Name Option -->
              <div id="shockByNameContainer" style="display: flex; align-items: center; margin-bottom: 12px;">
                <label style="min-width: 120px; color: rgb(143, 143, 143);">
                  <input type="radio" name="shockBy" value="name" onchange="handleShockByChange()"> Curve Name
                </label>
                <div id="curveNameSection" style="display: none; margin-left: 12px;">
                  <label for="curveNameSelect" style="margin-right: 8px; color: rgb(143, 143, 143);">Select
                    Curve:</label>
                  <select id="curveNameSelect" class="rounded-dropdown" style="color: rgb(143, 143, 143);"
                    onchange="proceedToScenario()"></select>
                </div>
              </div>
            </div>
          </div>

          <!--Shock By Curve Name Button, only displayed for data container curves-->
          <div id="dataContainerShockOptions" style="display: none;">
            <div id="dataContainerShockByName" style="display: flex; align-items: center; margin-bottom: 12px;">
              <label style="min-width: 120px; color: rgb(18, 18, 18);">
                <button id="shockByCurveNameBtn" type="button" class="green-button" onclick="shockByCurveNameBtn()">
                  Shock By Curve Name</button>
              </label>
              <div id="curveNameSectionDC" style="display: none; margin-left: 20px;">
                <label for="curveNameSelectDC"
                  style="margin-right: 8px; color: rgb(18, 18, 18); font-weight: bold;">Select
                  Curve:</label>
                <select id="curveNameSelectDC" class="rounded-dropdown" style="color: rgb(18, 18, 18);"
                  onchange="proceedToScenario()"></select>
              </div>
            </div>
          </div>

        </div>

        <div id="selectedCurves"></div>
      </div>
      <div id="missingCurvesSection" style="margin-top: 20px; color: rgb(80, 79, 79);"></div>
    </div>
  </div>

  <div id="main">
    <div id="curveContent" class="ml-4">
      <p>Select curve group and add scenarios</p>
    </div>
  </div>

  <script>
    // Get last modified time of the PAVE.exe file used by the website
    window.addEventListener("DOMContentLoaded", () => {
      fetch('/api/scenario-generation/PAVE-modified-time')
        .then(res => res.json())
        .then(data => {
          const el = document.getElementById('pave-version');
          if (data.modifiedTime) {
            const date = new Date(data.modifiedTime);
            const formatted = date.toLocaleString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              second: '2-digit',
              hour12: true
            });
            el.textContent = 'PAVE Engine Version: ' + formatted;
          } else {
            el.textContent = 'PAVE Engine Version: Not available';
          }
        })
        .catch(() => {
          document.getElementById('pave-version').textContent = 'PAVE Engine Version: Error fetching data';
        });
    });

    let currentShockBy = 'type'; // selected shock method (curve type, curve name, all)
    let scenarioSaved = false;
    const curveSelect = document.getElementById('curveNameSelect'); // shock by curve name - user's selected curve
    const selectedCurvesDiv = document.getElementById('selectedCurves'); // div where selected curves are displayed
    const curveContent = document.getElementById('curveContent'); // right side page (displays scenario generation form)
    const selectedCurves = new Set(); // tracks selected curves
    let pendingUpdates = []; // stores scenario form edits
    let missingCurves = []; // curves with no quotes data

    const curveSubsetSelect = document.getElementById('curveSubsetSelect'); // dropdown menu of curves

    const curveTypes = {
      Findur: {
        'Swap & Bond': ['Swap & Bond'],
        'CDS': ['CDS'],
        'CDX': ['CDX'],
        'CPI': ['CPI'],
        'IRPDF': ['IRPDF'],
        'Data Container': ['Data Container']
      },
      ALM: []
    };
    window.onload = updateCurveTypes;

    // Update page if curve source (Findur or ALM) changes
    document.getElementById('curveSource').addEventListener('change', () => {
      resetCurveGroup();
    });

    // Store user's input date
    let selectedDate = ''
    document.getElementById('curveDate').addEventListener('input', (e) => {
      selectedDate = e.target.value;
    });

    // Get user's selected curve type (Findur, ALM, etc)
    function getSelectedCurveType() {
      const selected = document.querySelector('input[name="curveType"]:checked');
      return selected ? selected.value : '';
    }

    // Activates shock by curve name button for data container curves
    function shockByCurveNameBtn() {
      // Set the shockBy radio button value to 'name'
      const existing = document.querySelector('input[name="shockBy"][value="name"]');
      if (existing) {
        existing.checked = true;
      }

      handleShockByChange();

      // Show the shock by curve name select curve dropdown
      const section = document.getElementById('curveNameSectionDC');
      if (section) {
        section.style.display = 'flex';
      }
    }

    // Display shock options for data container curves vs. other curves
    // Data container curves can only shock by curve name
    function updateShockOptionsVisibility() {
      const selectedType = getSelectedCurveType();
      const shockOptions = document.getElementById('shockOptions');
      const standardShock = document.getElementById('standardShock');
      const dataContainerShockOptions = document.getElementById('dataContainerShockOptions');

      if (selectedType === 'Data Container') {
        standardShock.style.display = 'none';
        dataContainerShockOptions.style.display = 'block';
      } else {
        standardShock.style.display = 'block';
        dataContainerShockOptions.style.display = 'none';
      }
    }

    // Update dropdown display of curves depending on curve class selected
    // Displays Swap & Bond, CDS & CDX, CPI options if selected Findur
    function updateCurveTypes() {
      const source = document.getElementById('curveSource').value;
      const container = document.getElementById('curveTypeContainer');
      const curveTypeSelect = document.getElementById('curveTypeSelect');

      container.innerHTML = '';

      if (source === 'Findur') {
        Object.keys(curveTypes.Findur).forEach((type, index) => {
          const label = document.createElement('label');
          label.style.display = 'block';
          label.innerHTML = `
        <input type="radio" name="curveType" value="${type}" ${index === 0 ? 'checked' : ''} />
        ${type}
      `;
          container.appendChild(label);
        });
      }

      // Update SHOCK BY CURVE TYPE dropdown options depending on curve class
      shockByCurveTypeOptions();

      populateCurveDropdown();

      // when curve type changes
      document.querySelectorAll('input[name="curveType"]').forEach(input => {
        input.addEventListener('change', () => {
          resetCurveGroup(); // clear selected curves
          populateCurveDropdown(); // refresh dropdown
          shockByCurveTypeOptions(); // refresh shock by curve type options
          updateShockOptionsVisibility();

          // Don't show Shock By Curve Type option for CPI curves
          const curveType = input.value;
          const shockCurveTypeContainer = document.getElementById('shockCurveTypeContainer');
          if (shockCurveTypeContainer) {
            shockCurveTypeContainer.style.display = curveType === 'CPI' ? 'none' : 'flex';
          }
        })
      });
    }

    // Updates options for Shock By Curve Type depending on curve class
    function shockByCurveTypeOptions() {
      const source = document.getElementById('curveSource').value;
      const curveTypeSelect = document.getElementById('curveTypeSelect');
      const curveTypeInput = document.querySelector('input[name="curveType"]:checked');
      const curveType = curveTypeInput ? curveTypeInput.value : null;
      const curveTypeSection = document.getElementById('curveTypeSection');

      if (curveTypeSelect) {
        curveTypeSelect.innerHTML = '';
        if (source === 'ALM') {
          curveTypeSelect.innerHTML = `
        <option value="RiskFree">RiskFree</option>
        <option value="CreditSpread">CreditSpread</option>
      `;
        } else if (source === 'Findur' && (curveType === 'CDS' || curveType === 'CDX')) {
          curveTypeSelect.innerHTML = `
        <option value="YieldCurve">YieldCurve</option>
        <option value="Surv">Surv</option>
      `;
        } else if (source === 'Findur' && curveType === 'IRPDF') {
          curveTypeSelect.innerHTML = `
        <option value="YieldCurve">YieldCurve</option>
        <option value="FXForward">FXForward</option>
      `;
        } else {
          curveTypeSelect.innerHTML = `
        <option value="Bond">Bond</option>
        <option value="YieldCurve">YieldCurve</option>
      `;
        }
      }
    }

    // Populates dropdown with list of all curves for specific curve class
    function populateCurveDropdown() {
      const source = document.getElementById('curveSource').value;
      const type = document.querySelector('input[name="curveType"]:checked')?.value || '';

      const curveSelect = document.getElementById('curveSubsetSelect');

      curveSelect.innerHTML = '';

      fetch(`/api/scenario-generation/all-curve-names?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`)
        .then(res => res.json())
        .then(curves => {
          curves.forEach(name => {
            const option = document.createElement('option');
            option.textContent = name;
            curveSelect.appendChild(option);
          });
        })
        .catch(err => {
          console.error('❌ Failed to fetch curves:', err);
        });
    }

    // Updates CDef_ScenarioGroup.txt for each curve user selects
    function addCurveToSubset() {
      const selected = Array.from(curveSubsetSelect.selectedOptions).map(opt => opt.value);
      selected.forEach(name => selectedCurves.add(name));

      document.getElementById('selectedCurveList').textContent = Array.from(selectedCurves).join(', ');

      const curves = Array.from(selectedCurves);
      const source = document.getElementById('curveSource').value;
      const type = document.querySelector('input[name="curveType"]:checked')?.value || '';

      fetch('/api/scenario-generation/generate-selected-curves-def', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ curves, source, type })
      })
        .then(res => res.json())
        .then(data => {
          console.log('✅ Curve group saved:', data.message);
        })
        .catch(err => {
          console.error('❌ Failed to generate master files:', err);
        });
    }

    // Filter dropdown options based on user input
    document.getElementById('curveSearch').addEventListener('input', function () {
      const searchTerm = this.value.toLowerCase();
      const options = curveSubsetSelect.options;
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        const text = option.textContent.toLowerCase();
        option.style.display = text.includes(searchTerm) ? '' : 'none';
      }
    });

    // Resets selected curve group
    function resetCurveGroup() {
      document.getElementById("selectedCurves").innerHTML = "";
      document.getElementById("selectedCurveList").innerHTML = "";
      document.getElementById("curveContent").innerHTML = "";
      selectedCurves.clear(); // clear list of selected curves
      shockByCurveTypeOptions(); // change shock by curve type options based on curve class
      const advancedSettings = document.getElementById('advancedSettings'); // hide advanced settings
      advancedSettings.style.display = 'none';

      fetch('/api/scenario-generation/clear-curve-files', {
        method: 'POST'
      })
        .then(res => res.json())
        .then(data => {
          if (data.status === 'success') {
            console.log('✅ Curve group reset.');
          } else {
            alert('⚠️ Failed to reset curve group: ' + data.message);
          }
        })
        .catch(err => {
          console.error('❌ Error resetting curve group:', err);
          alert('❌ Error resetting curve group.');
        })
    }

    // Show advanced shock methods (curve type, curve name) when user clicks Advanced Settings
    function toggleAdvancedSettings() {
      const section = document.getElementById('advancedSettings');
      section.style.display = section.style.display === 'none' ? 'block' : 'none';
    }

    // Display scenario from when user clicks 'Shock All' button
    function shockAll() {
      currentShockBy = 'ALL';
      document.getElementById('curveTypeSection').style.display = 'none';
      document.getElementById('curveNameSection').style.display = 'none';
      openScenarioForm('ALL');
    }

    // Show further options for Shock By Curve Type and Shock By Curve Name
    function handleShockByChange() {
      const selected = document.querySelector('input[name="shockBy"]:checked').value;

      document.getElementById('curveTypeSection').style.display = selected === 'type' ? 'block' : 'none';
      document.getElementById('curveNameSection').style.display = selected === 'name' ? 'block' : 'none';
      document.getElementById('curveNameSectionDC').style.display = selected === 'name' ? 'block' : 'none';

      // Automatically proceed to scenario form
      proceedToScenario();
    }


    // Fetch quotes data for selected curves and display view definition, edit quotes options for each curve
    function getQuotesData() {
      document.getElementById('loadingMessage').classList.remove('hidden');
      const date = document.getElementById('curveDate').value;
      const source = document.getElementById('curveSource').value;
      const type = getSelectedCurveType();

      if (!date) {
        alert('Please enter a valuation date.');
        document.getElementById('loadingMessage').classList.add('hidden');
        return;
      }

      fetch('/api/scenario-generation/generate-quotes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ date, source, type })
      })
        .then(res => res.json())
        .then(data => {
          missingCurves = data.missingCurves;
          if (missingCurves && missingCurves.length > 0) {
            alert(`⚠️ Curves without data for ${date}:\n\n` + missingCurves.join('\n'));
          } else {
            alert('✅ Quotes data generated successfully.');
          }
          document.getElementById('loadingMessage').classList.add('hidden');

          const selectedCurvesDiv = document.getElementById('selectedCurves');

          fetch('/api/scenario-generation/quotes-curve-list')
            .then(res => res.json())
            .then(data => {
              const curves = data.curves || [];
              // console.log(curves);

              curves.forEach(name => {
                const div = document.createElement('div');
                div.className = 'curve-item';
                const showDefinitionButton = source !== 'ALM';
                div.innerHTML = `
              <div style="margin-top: 5px; margin-bottom: 5px;">
                <strong>${name}</strong><br/>
                <div class="flex mt-2">
                  <nav class="flex overflow-x-auto items-center p-1 space-x-1 text-sm text-gray-600 bg-gray-100 rounded-xl">
                    ${showDefinitionButton ? `
                    <button type="button"
                      onclick="viewDefinition('${name}')"
                      class="whitespace-nowrap flex items-center h-8 px-4 font-medium rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400">
                      View Definition
                    </button>` : ''}
                    <button type="button"
                      onclick="${getSelectedCurveType() === 'CPI'
                    ? `viewCPIQuotes('${name}')`
                    : (getSelectedCurveType() === 'Data Container' || getSelectedCurveType() === 'IRPDF')
                      ? `viewDataContainerIRPDFQuotes('${name}')`
                      : `editSwapBondQuotes('${name}')`
                  }"
                      class="whitespace-nowrap flex items-center h-8 px-4 font-medium rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400">
                      Edit Quotes
                    </button>
                  </nav>
                </div>
                <div id="parents-${name}" style="margin-top: 5px; font-size: 0.9em; color: #555;"></div>
              </div>
            `;
                selectedCurvesDiv.appendChild(div);

                // Fetch and display parent curves
                fetch(`/api/scenario-generation/parents/${name}?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`)
                  .then(res => res.json())
                  .then(data => {
                    const parentText = data.parents?.length
                      ? `Parent Curves: ${data.parents.join(', ')}`
                      : 'Parent Curves: None';
                    document.getElementById(`parents-${name}`).textContent = parentText;
                  })
                  .catch(err => console.error(`Failed to fetch parents for ${name}:`, err));
              });

              // Populate Shock By: Curve Name dropdown based on user's selected group of curves
              const curveNameSelect = document.getElementById('curveNameSelect');
              curveNameSelect.innerHTML = '';
              curves.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                curveNameSelect.appendChild(option);
              });

              // Same thing as above for data container curve, shock by curve name option
              const curveNameSelectDC = document.getElementById('curveNameSelectDC');
              curveNameSelectDC.innerHTML = '';
              curves.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                curveNameSelectDC.appendChild(option);
              });

              document.getElementById('selectedCurveList').textContent = curves.join(', ');
            })
            .catch(err => {
              console.error('❌ Failed to fetch curve list:', err);
              document.getElementById('loadingMessage').classList.add('hidden');
              alert('❌ Failed to fetch curve list.');
            });
        })
        .catch(err => {
          console.error('❌ Failed to get quotes data:', err);
          alert('❌ Failed to get quotes data.');
        });
    }

    // Display curve's definition file
    function viewDefinition(curveName) {
      const source = document.getElementById('curveSource').value;
      const type = getSelectedCurveType();

      fetch(`/api/scenario-generation/definition/${curveName}?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`)
        .then(res => res.text())
        .then(data => {
          curveContent.innerHTML = `<h3 class="text-lg font-semibold text-gray-800 mb-2">${curveName} - Definition</h3><pre>${data}</pre>`;
        });
    }

    // Creates unique indentifiers for each row of quote data, used to match edited quotes with corresponding original values
    function generateRowKey(row) {
      const keyParts = [];
      for (const [k, v] of Object.entries(row)) {
        if (isNaN(v) || v === '') {
          keyParts.push(v?.trim());
        }
        if (keyParts.length >= 2) break;
      }
      return keyParts.join('_');
    }

    // Display quotes table for Data Container and IRPDF curves
    function viewDataContainerIRPDFQuotes(curveName) {
      pendingUpdates = [];
      const source = document.getElementById('curveSource').value;
      const type = getSelectedCurveType();

      Promise.all([
        fetch(`/api/scenario-generation/quotes/${curveName}?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`).then(res => res.text()),
        fetch(`/api/scenario-generation/original-quotes/${curveName}`).then(res => res.text())
      ]).then(([editableData, originalData]) => {
        // console.log(originalData);
        const parseCurveBlock = (data) => {
          const blocks = data.split('#BeginCurve').filter(Boolean);
          return blocks.map(block => {
            const lines = block.trim().split('\n');
            const nameLine = lines.find(line => line.startsWith('CurveName'));
            const curve = nameLine ? nameLine.split(/\s+/)[1] : 'Unknown';
            const quoteStart = lines.findIndex(line => line.includes('///:CurveMarketQuotes'));
            if (quoteStart === -1) return null;

            const headers = lines[quoteStart + 1].trim().split('\t');
            const rows = [];

            for (let i = quoteStart + 3; i < lines.length; i++) {
              const line = lines[i].trim();
              if (line.startsWith('#EndCurve') || line === '') break;
              const values = line.split('\t');
              const row = {};
              headers.forEach((h, idx) => row[h] = values[idx] ?? '');
              rows.push(row);
            }

            return { curveName: curve, headers, rows };
          }).filter(Boolean);
        };

        const editableBlocks = parseCurveBlock(editableData);
        const originalBlocks = parseCurveBlock(originalData);

        const targetBlock = editableBlocks.find(b => b.curveName === curveName);
        const originalBlock = originalBlocks.find(b => b.curveName === curveName);

        if (!targetBlock || targetBlock.rows.length === 0) {
          curveContent.innerHTML = `<h3 class="quote-heading">${curveName} - Quotes</h3><p>No quotes data available.</p>`;
          return;
        }

        const originalMap = new Map();
        originalBlock?.rows.forEach(row => {
          const key = generateRowKey(row);
          originalMap.set(key, row);
        });
        // console.log(originalMap);

        const numericFields = new Set();
        targetBlock.rows.forEach(row => {

          Object.entries(row).forEach(([key, val]) => {
            if (!isNaN(val) && /^\d+(\.\d+)?$/.test(val)) {
              numericFields.add(key);
            }
          });
        });

        let adjustFieldOptions = '';
        [...numericFields].forEach(field => {
          const label = field === 'Rate' ? 'Rate (decimal)' : `${field}`;
          adjustFieldOptions += `<option value="${field}">${label}</option>`;
        });
        const isBondCurve = curveName.startsWith('BOND_PRICES');

        let html = `
      <h3 class="text-lg font-semibold text-gray-800 mb-2">${curveName} - Quotes</h3>
    `;

        html += `
        <div id="adjustAllContainer" class="mt-4">
          <strong class="block text-sm font-semibold text-gray-700 mb-2">Adjust Input:</strong>
          <div class="flex flex-wrap gap-2 mb-3">
            <select id="adjustField" class="px-2 py-1 text-sm text-gray-700 border rounded">
              ${adjustFieldOptions}
            </select>
            <select id="adjustOp" class="px-2 py-1 text-sm text-gray-700 border rounded">
              <option value="+">+</option>
              <option value="-">-</option>
            </select>
            <input type="number" id="adjustValue" step="0.0001" placeholder="Enter value"
              class="px-2 py-1 text-sm text-gray-700 border rounded w-28" />
            <button onclick="adjustAllQuotes()" class="blue-button">Apply</button>
          </div>
          <button class="green-button mb-4" onclick="saveAllChanges()">Save Changes</button>
        </div>
      `;

        html += `
      <div class="quote-block" data-curve="${curveName}" data-source="${curveName}">
        <div class="overflow-x-auto">
          <table class="w-auto max-w-5xl border border-gray-300 divide-y divide-gray-200 text-sm text-gray-900 mb-6 rounded-md">
            <thead class="bg-gray-50">
              <tr>
                ${targetBlock.headers.map(h => `<th class="px-3 py-2 border-r border-gray-200 text-left">${h}</th>`).join('')}
                ${!isBondCurve ? targetBlock.headers.map(h => numericFields.has(h) ? `<th class="px-3 py-2 border-r border-gray-200 text-left">Original ${h}</th>` : '').join('') : ''}
              </tr>
            </thead>
            <tbody class="divide-y divide-gray-200">
    `;

        targetBlock.rows.forEach(row => {
          const key = generateRowKey(row);
          const original = originalMap.get(key) || {};
          html += `<tr>`;
          targetBlock.headers.forEach(h => {
            const val = row[h] ?? '';
            const editable = !isNaN(val) && /^\d+(\.\d+)?$/.test(val) && val.toUpperCase() != 'NULL'; // user can't edit NULL and non-numeric fields
            html += `<td class="px-3 py-2 border-r border-gray-200" ${editable ? `contenteditable="true" data-field="${h}" onblur="trackEdit('${curveName}', '${h}', this)"` : ''}>${val}</td>`;
          });
          if (!isBondCurve) {
            targetBlock.headers.forEach(h => {
              if (numericFields.has(h)) {
                html += `<td class="px-3 py-2 border-r border-gray-200 text-gray-500">${original[h] ?? ''}</td>`;
              }
            });
          }
          html += `</tr>`;
        });

        html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

        curveContent.innerHTML = html;
      });
    }

    // Display quotes table for CPI curves
    function viewCPIQuotes(curveName) {
      Promise.all([
        fetch(`/api/scenario-generation/cpi-quotes/${curveName}`).then(res => res.json()),
        fetch(`/api/scenario-generation/original-cpi-quotes/${curveName}`).then(res => res.json())
      ])
        .then(([editable, original]) => {
          const originalMap = new Map(original.historicalCPI.map(r => [r.date, r.rate]));
          const seasonMap = new Map(original.seasonalityRate.map(r => [r.month, r.rate]));
          const zcisMap = new Map(original.zcis.map(r => [r.years, r.yield]));

          let html = `
      <h3 class="text-lg font-semibold text-gray-800 mb-4">${curveName} - CPI Quotes</h3>
      <button class="green-button mb-6" onclick="saveCPIChanges('${curveName}')">Save Changes</button>

      <h4 class="font-bold mb-2">Historical CPI</h4>
      <table class="w-auto text-sm border border-gray-300 mb-6">
        <thead class="bg-gray-100">
          <tr>
            <th class="px-3 py-2 border">Date</th>
            <th class="px-3 py-2 border">Original Rate</th>
            <th class="px-3 py-2 border">Edit Rate</th>
          </tr>
        </thead>
        <tbody>
          ${editable.historicalCPI.map(row => {
            const orig = originalMap.get(row.date) ?? 'N/A';
            return `<tr>
              <td class="px-3 py-2 border">${row.date}</td>
              <td class="px-3 py-2 border bg-gray-100">${orig}</td>
              <td class="px-3 py-2 border" contenteditable="true" onblur="this.style.backgroundColor='#ffffcc'">${row.rate}</td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>

      <h4 class="font-bold mb-2">Seasonality Rate</h4>
      <table class="w-full text-sm border border-gray-300 mb-6">
        <thead class="bg-gray-100">
          <tr>
            <th class="px-3 py-2 border">Month</th>
            <th class="px-3 py-2 border">Original Rate</th>
            <th class="px-3 py-2 border">Edit Rate</th>
          </tr>
        </thead>
        <tbody>
          ${editable.seasonalityRate.map(row => {
            const orig = seasonMap.get(row.month) ?? 'N/A';
            return `<tr>
              <td class="px-3 py-2 border">${row.month}</td>
              <td class="px-3 py-2 border bg-gray-100">${orig}</td>
              <td class="px-3 py-2 border" contenteditable="true" onblur="this.style.backgroundColor='#ffffcc'">${row.rate}</td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>

      <h4 class="font-bold mb-2">Zero Coupon Inflation Swap (ZCIS)</h4>
      <table class="w-full text-sm border border-gray-300 mb-6">
        <thead class="bg-gray-100">
          <tr>
            <th class="px-3 py-2 border">Years</th>
            <th class="px-3 py-2 border">Original Yield</th>
            <th class="px-3 py-2 border">Edit Yield</th>
          </tr>
        </thead>
        <tbody>
          ${editable.zcis.map(row => {
            const orig = zcisMap.get(row.years) ?? 'N/A';
            return `<tr>
              <td class="px-3 py-2 border">${row.years}</td>
              <td class="px-3 py-2 border bg-gray-100">${orig}</td>
              <td class="px-3 py-2 border" contenteditable="true" onblur="this.style.backgroundColor='#ffffcc'">${row.yield}</td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>
    `;

          document.getElementById('curveContent').innerHTML = html;
        })
        .catch(err => {
          console.error('Failed to load CPI quotes:', err);
          alert('Error loading CPI quotes.');
        });
    }

    // Send CPI quotes changes to backend
    function saveCPIChanges(curveName) {
      const tables = document.querySelectorAll('#curveContent table');
      const [histTable, seasonTable, zcisTable] = tables;

      const historicalCPI = Array.from(histTable.rows).slice(1).map(row => ({
        date: row.cells[0].innerText.trim(),
        rate: parseFloat(row.cells[2].innerText.trim())
      }));

      const seasonalityRate = Array.from(seasonTable.rows).slice(1).map(row => ({
        month: row.cells[0].innerText.trim(),
        rate: parseFloat(row.cells[2].innerText.trim())
      }));

      const zcis = Array.from(zcisTable.rows).slice(1).map(row => ({
        years: parseFloat(row.cells[0].innerText.trim()),
        yield: parseFloat(row.cells[2].innerText.trim())
      }));

      fetch(`/api/scenario-generation/save-cpi-quotes/${curveName}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ historicalCPI, seasonalityRate, zcis })
      })
        .then(res => res.json())
        .then(data => {
          alert(data.message || '✅ Changes saved!');
        })
        .catch(err => {
          console.error('❌ Failed to save CPI changes:', err);
          alert('Failed to save changes.');
        });
    }

    // Allow user to edit rate and spread values in table format
    function editSwapBondQuotes(curveName) {
      const isALM = document.getElementById('curveSource').value === 'ALM';
      pendingUpdates = [];
      const source = document.getElementById('curveSource').value;
      const type = getSelectedCurveType();

      Promise.all([
        fetch(`/api/scenario-generation/quotes/${curveName}?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`).then(res => res.text()),
        fetch(`/api/scenario-generation/original-quotes/${curveName}`).then(res => res.text())
      ]).then(([editableData, originalData]) => {

        const parseMultipleCurveBlocks = (data) => {
          const blocks = data.split('#BeginCurve').filter(Boolean);
          return blocks.map(block => {
            const lines = block.split('\n');
            const nameLine = lines.find(line => line.startsWith('CurveName'));
            const curve = nameLine ? nameLine.split(/\s+/)[1] : 'Unknown';

            let startIndex = lines.findIndex(line => line.includes('///:CurveMarketQuotes'));
            let isALMBlock = false;
            if (startIndex === -1) {
              startIndex = lines.findIndex(line => line.includes('///:CurveDefinition'));
              isALMBlock = true;
            }

            const rows = [];
            for (let i = startIndex + 3; i < lines.length; i++) {
              const line = lines[i].trim();
              if (line.startsWith('#EndCurve') || line === '') break;
              const parts = line.split(/\s+/);
              if (parts.length >= 4) {
                const row = {
                  SecType: parts[0],
                  Tenor: parts[1],
                  Rate: parts[2],
                  Spread: parts[3],
                };

                if (parts.length > 4) {
                  row.CustomizedSpread = parts[4];
                }

                rows.push(row);
              }
            }

            return { curveName: curve, rows };
          });
        };

        const editableBlocks = parseMultipleCurveBlocks(editableData);
        const originalBlocks = parseMultipleCurveBlocks(originalData);

        // Map original values for comparison
        const originalMap = {};
        originalBlocks.forEach(block => {
          block.rows.forEach(row => {
            originalMap[`${block.curveName}_${row.SecType}_${row.Tenor}`] = row;
          });
        });

        // Only show quotes for selected curve (exclude parent curves)
        const targetBlock = editableBlocks.find(block => block.curveName === curveName);
        if (!targetBlock || targetBlock.rows.length === 0) {
          curveContent.innerHTML = `<h3 class="quote-heading">${curveName} - Quotes</h3><p>No quotes data available.</p>`;
          return;
        }

        // Detect numeric fields for adjust input columns
        const numericFields = new Set();
        targetBlock.rows.forEach(row => {
          Object.entries(row).forEach(([key, val]) => {
            if (!isNaN(val) && /^\d+(\.\d+)?$/.test(val)) {
              numericFields.add(key);
            }
          });
        });

        let adjustFieldOptions = '';
        [...numericFields].forEach(field => {
          const label = field === 'Rate' ? 'Rate (decimal)' : `${field} (bps)`;
          adjustFieldOptions += `<option value="${field}">${label}</option>`;
        });
        // console.log(numericFields)

        let html = `
        <h3 class="text-lg font-semibold text-gray-800 mb-2">${curveName} - Quotes</h3>
      <div id="adjustAllContainer" class="mt-4">
        <strong class="block text-sm font-semibold text-gray-700 mb-2">Adjust Input:</strong>
        <div class="flex flex-wrap gap-2 mb-3">
          <select id="adjustField" class="px-2 py-1 text-sm text-gray-700 border rounded">
            ${adjustFieldOptions}
          </select>
          <select id="adjustOp" class="px-2 py-1 text-sm text-gray-700 border rounded">
            <option value="+">+</option>
            <option value="-">-</option>
          </select>
          <input type="number" id="adjustValue" step="0.0001" placeholder="Enter value"
            class="px-2 py-1 text-sm text-gray-700 border rounded w-28" />
          <button onclick="adjustAllQuotes()" class="blue-button">Apply</button>
        </div>
        <button class="green-button mb-4" onclick="saveAllChanges()">Save Changes</button>
      </div>
      <div class="quote-block" data-curve="${curveName}" data-source="${curveName}">
        <div class="overflow-x-auto">
        <table class="w-auto max-w-5xl border border-gray-300 divide-y divide-gray-200 text-sm text-gray-900 mb-6 rounded-md">
          <thead class="bg-gray-50">
            <tr>
              <th class="px-3 py-2 border-r border-gray-200 text-left">SecType</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Tenor</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Original Rate</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Edit Rate</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Original ${isALM ? 'MarketSpread' : 'Spread'}</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Edit ${isALM ? 'MarketSpread' : 'Spread'}</th>
              ${isALM ? '<th class="px-3 py-2 border-r border-gray-200 text-left">Original CustomizedSpread</th>' : ''}
              ${isALM ? '<th class="px-3 py-2 text-left">Edit CustomizedSpread</th>' : ''}
            </tr>
          </thead>
          <tbody class="divide-y divide-gray-200">
    `;

        targetBlock.rows.forEach(row => {
          const key = `${curveName}_${row.SecType}_${row.Tenor}`;
          const original = originalMap[key] || { Rate: 'N/A', Spread: 'N/A', CustomizedSpread: '0' };

          html += `<tr>
        <td class="px-3 py-2 border-r border-gray-200">${row.SecType}</td>
        <td class="px-3 py-2 border-r border-gray-200">${row.Tenor}</td>
        <td class="px-3 py-2 border-r border-gray-200 bg-gray-100">${original.Rate}</td>
        <td class="px-3 py-2 border-r border-gray-200" data-field="Rate" 
        ${row.Rate?.toUpperCase() !== 'NULL' ? 'contenteditable="true"' : ''}
    onblur="trackEdit('${curveName}', 'Rate', this)">
    ${row.Rate}
</td>
<td class="px-3 py-2 border-r border-gray-200 bg-gray-100">${original.Spread}</td>
<td class="px-3 py-2 border-r border-gray-200" data-field="Spread" 
${row.Spread?.toUpperCase() !== 'NULL' ? 'contenteditable="true"' : ''}
    onblur="trackEdit('${curveName}', 'Spread', this)">
    ${row.Spread}
</td>
${isALM ? `<td class="px-3 py-2 border-r border-gray-200 bg-gray-100">${original.CustomizedSpread}</td>` : ''}
${isALM ? `<td class="px-3 py-2" data-field="CustomizedSpread" 
${row.CustomizedSpread?.toUpperCase() !== 'NULL' ? 'contenteditable="true"' : ''}
    onblur="trackEdit('${curveName}', 'CustomizedSpread', this)">
    ${row.CustomizedSpread}
</td>` : ''}
      </tr>`;
        });

        html += `
          </tbody>
        </table>
      </div>
    `;

        curveContent.innerHTML = html;
      });
    }

    // Add or subtract values for entire column of specific curve
    function adjustAllQuotes() {
      const field = document.getElementById('adjustField').value;
      const curve = document.querySelector('.quote-block')?.getAttribute('data-curve');
      const operation = document.getElementById('adjustOp').value;
      const value = new Decimal(document.getElementById('adjustValue').value);


      if (value.isNaN()) {
        alert('Please enter a valid number.');
        return;
      }

      const blocks = document.querySelectorAll(`.quote-block[data-curve="${curve}"]`);
      blocks.forEach(block => {
        const sourceCurve = block.getAttribute('data-source');
        const rows = block.querySelectorAll('tbody tr');

        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          const secType = cells[0].innerText.trim();
          const tenor = cells[1].innerText.trim();
          const isParent = curve !== sourceCurve;

          const isALM = document.getElementById('curveSource').value === 'ALM';
          // ALM Curves: Convert Spread to MktSpread for editing backend file
          const normalizedField = isALM && field === 'Spread' ? 'MktSpread' : field;
          let targetCell = Array.from(row.querySelectorAll('td')).find(td => td.getAttribute('data-field') === field);

          console.log(`Trying to adjust ${normalizedField} for ${curve}, ${secType}, ${tenor}`);
          console.log('Found cell:', targetCell);


          if (!targetCell) return;

          const rawValue = targetCell.innerText.trim();
          if (rawValue.toUpperCase() === 'NULL' || rawValue === '') return;

          const currentValue = new Decimal(rawValue);

          if (!currentValue.isNaN()) {
            const newValue = operation === '+' ? currentValue.plus(value) : currentValue.minus(value);
            targetCell.innerText = newValue.toString();
            trackEdit(curve, normalizedField, targetCell);
          }
        });
      });
    }


    // Tracks changes made to quote fields -- sends index of edited row to backend for updating txt file
    function trackEdit(curveName, field, cell) {
      const row = cell.closest('tr');
      const rowIndex = Array.from(row.parentNode.children).indexOf(row);
      const newValue = cell.innerText.trim();
      const sourceCurve = document.querySelector('.quote-block[data-curve]')?.getAttribute('data-source') || curveName;

      pendingUpdates.push({
        curveName,
        rowIndex,
        field,
        newValue,
        sourceCurve
      });

      cell.style.backgroundColor = '#ffffcc';
    }


    // Saves all changes to quotes file after user clicks save changes button
    // Saves quote data changes
    function saveAllChanges() {
      if (pendingUpdates.length === 0) {
        alert('No changes to save.');
        return;
      }

      const updatesByFile = {};
      pendingUpdates.forEach(update => {
        const file = update.sourceCurve;
        if (!updatesByFile[file]) updatesByFile[file] = [];
        updatesByFile[file].push(update);
      });

      const requests = Object.entries(updatesByFile).flatMap(([fileCurve, updates]) =>
        updates.map(update =>
          fetch(`/api/scenario-generation/save-quote-changes/${update.curveName}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ...update, sourceCurve: fileCurve })
          })
        )
      );

      Promise.all(requests)
        .then(() => {
          alert('✅ All changes saved!');
          pendingUpdates = [];
          document.querySelectorAll('td[contenteditable]').forEach(td => td.style.backgroundColor = '');
        })
        .catch(err => {
          console.error('❌ Failed to save changes:', err);
          alert('Some changes failed to save.');
        });
    }

    // Run PAVE on selected curves and scenarios
    // Displays output and allows user to download
    function runSelectedCurves() {
      if (!scenarioSaved) {
        alert('⚠️ Save scenario before running');
        return;
      }

      const curves = Array.from(selectedCurves);
      const valuationDate = document.getElementById('curveDate').value;
      const type = getSelectedCurveType();

      // Running... message
      const linkContainer = document.getElementById('linkContainer');
      const runningMsg = document.createElement('p');
      runningMsg.id = 'runningMessage';
      runningMsg.className = 'text-green-600 text-base mt-2';
      runningMsg.textContent = 'Running...';
      linkContainer.appendChild(runningMsg);

      const source = document.getElementById('curveSource').value;

      fetch('/api/scenario-generation/run-scenario-generation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ valuationDate, source, type })
      })
        .then(res => res.json())
        .then(results => {
          scenarioSaved = false;
          curveContent.innerHTML = `<h3 class="quote-heading">Output</h3>`;
          if (Array.isArray(results) && results.length > 0) {
            const result = results[0];
            curveContent.innerHTML += `
  <div class="flex gap-2 mb-6">
    <a href="/api/scenario-generation/download/scenarioOutput" download>
      <button class="blue-button mt-2 mb-2">Download Output</button>
    </a>
    <a href="/api/scenario-generation/download/scenarioQuotes" download>
      <button class="blue-button mt-2 mb-2">Download Quotes</button>
    </a>
    <a href="/api/scenario-generation/download/debug" download>
      <button class="blue-button mt-2 mb-2">Download Debug.txt</button>
    </a>
  </div>

  <div class="flex gap-6 mt-4">
    <div class="flex-1">
      <pre class="bg-gray-100 p-2" style="white-space: pre-wrap; word-break: break-word;">${result.output}</pre>
    </div>
    <div class="flex-1">
      ${missingCurves.length > 0 ? `
    <div class="mb-4">
      <strong>⚠️ Curves Without Data for ${valuationDate}:</strong>
      <ul class="list-disc list-inside">
        ${missingCurves.map(curve => {
              const label = selectedCurves.has(curve) ?
                `${curve} (selected curve)` :
                `${curve} (parent curve)`;
              return `<li>${label}</li>`;
            }).join('')}
      </ul>
    </div>
      ` : ''}
  
      <pre class="bg-gray-100 p-2" style="white-space: pre-wrap; word-break: break-word;">${result.debug}</pre>
    </div>
  </div>
`;
          } else {
            curveContent.innerHTML += `<p style="color: red;">⚠️ No scenario output returned.</p>`;
          }

          const msg = document.getElementById('runningMessage');
          if (msg) msg.remove();
        });
    }

    // Trigger scenario form based on selection
    function proceedToScenario() {
      currentShockBy = document.querySelector('input[name="shockBy"]:checked').value;
      let curveName = '';
      if (currentShockBy === 'type') {
        curveName = document.getElementById('curveTypeSelect').value;
      } else if (currentShockBy === 'name') {
        const standard = document.getElementById('curveNameSelect');
        const dataContainer = document.getElementById('curveNameSelectDC');

        if (dataContainer && dataContainer.offsetParent != null) {
          curveName = dataContainer.value;
        } else {
          curveName = standard.value;
        }
      } else {
        curveName = 'ALL';
      }
      openScenarioForm(curveName);
    }

    // Generates scenario form
    function openScenarioForm(curveName) {
      const source = document.getElementById('curveSource').value;
      const type = getSelectedCurveType();
      const isShockByName = document.querySelector('input[name="shockBy"]:checked')?.value === 'name';

      fetch(`/api/scenario-generation/parents/${curveName}?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`)
        .then(res => res.json())
        .then(data => {
          const parentCurves = data.parents || [];
          const childCurveName = curveName;
          const shockMethodSelect = document.getElementById('shockMethodSelect');
          const method = shockMethodSelect ? shockMethodSelect.value : 'tenor';

          let curveCategory = '';
          if (type === 'Data Container') {
            fetch(`/api/scenario-generation/curve-category/${encodeURIComponent(curveName)}`)
              .then(response => response.json())
              .then(data => {
                curveCategory = data.curveCategory;

                const priceCurveWithTenor = type === 'Data Container' && (curveCategory == 'FXCurve' || curveCategory == 'ForwardPriceCurve');

                if (isShockByName && priceCurveWithTenor) {
                  fetch(`/api/scenario-generation/tenors/${curveName}?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`)
                    .then(res => res.json())
                    .then(data => {
                      document.getElementById('tenorFormContainer').style.display = 'none';
                      document.getElementById('gridFormContainer').style.display = 'block';
                      renderGridPointScenarioForm(curveName, data.tenors);
                      return;
                    })
                    .catch(err => {
                      console.error('Failed to fetch tenors:', err);
                      alert('Could not load tenors for grid point shock.');
                    });
                }
                else if (isShockByName && parentCurves.length === 0 && type === 'Data Container') {
                  fetch(`/api/scenario-generation/risk-factors/${curveName}`)
                    .then(res => res.json())
                    .then(data => {
                      document.getElementById('tenorFormContainer').style.display = 'none';
                      document.getElementById('gridFormContainer').style.display = 'block';
                      renderGridPointScenarioForm(curveName, data.riskFactors);
                      return;
                    })
                    .catch(err => {
                      console.error('Failed to fetch risk factors:', err);
                      alert('Could not load risk factors for grid point shock.');
                    });
                }
              })
              .catch(err => {
                console.error("Error fetching curve category:", err);
              })
          } 
          
          renderScenarioForm(curveName, parentCurves, childCurveName);

          // if (isShockByName && parentCurves.length === 0 && method === 'grid') {
          //   fetch(`scenario-generation/tenors/${curveName}?source=${encodeURIComponent(source)}&type=${encodeURIComponent(type)}`)
          //     .then(res => res.json())
          //     .then(data => {
          //       document.getElementById('tenorFormContainer').style.display = 'none';
          //       document.getElementById('gridFormContainer').style.display = 'block';
          //       renderGridPointScenarioForm(curveName, data.tenors);
          //     })
          //     .catch(err => {
          //       console.error('Failed to fetch tenors:', err);
          //       alert('Could not load tenors for grid point shock.');
          //     });
          // }
        })
        .catch(err => {
          console.error('Failed to fetch parent curves:', err);
        });
    }

    // Displays scenario form on frontend for user to edit
    function renderScenarioForm(curveName, parentCurveName, childCurveName) {
      const curveContent = document.getElementById('curveContent');
      const defaultRow = ['BaseCase', curveName, ...Array(10).fill('0')];
      const hasSpecificCurveName = curveName && !['Curve Type', 'All'].includes(curveName);

      // Show inheritance options if selected curve has parent curve
      const showShockOptions = currentShockBy === 'name' && hasSpecificCurveName &&
        Array.isArray(parentCurveName) && parentCurveName.length > 0;

      const type = getSelectedCurveType();
      const shockVal = type === 'Data Container' ? '0.01' : '0.001';

      const prefix = type === 'Data Container' ? 'EQ' : 'IR';

      let html = `
    <h3 class="quote-heading">Shock By: ${curveName}</h3>
    ${currentShockBy === 'name' ? `
      <div id="parentCurvesLine" style="margin-bottom: 20px; font-size: 0.95em; color: #555;">
        Parent Curves: ${Array.isArray(parentCurveName) && parentCurveName.length > 0 ? parentCurveName.join(', ') : 'None'}
      </div>
    ` : ''}
    <div style="display: flex; gap: 80px; margin-top: 10px; margin-bottom: 10px;">
      <div style="display: flex; flex-direction: column; gap: 10px;">
        <label class="label-group">${prefix} Data Type:
          <select id="scenarioIRDataType" class="rounded-dropdown">
            <option value="bps">bps</option>
            <option value="decimal">decimal</option>
          </select>
        </label>
        <label class="label-group" id="irShockTypeContainer">IR Shock Type:
          <select id="scenarioShockType" class="rounded-dropdown">
            <option value="">Rate</option>
            <option value="Spread">Spread</option>
          </select>
        </label>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
          <span style="font-weight: 500;">Greek:</span>
          <span>Off</span>
          <label class="toggle-switch" style="display: flex; align-items: center;">
            <input type="checkbox" id="scenarioGreekToggle">
            <span class="slider"></span>
          </label>
          <span>On</span>
          <span id="shockAmountDisplay" style="display: none; margin-left: 10px; font-size: 0.9em; color: #555;">
            IR Shock Amount: <span id="shockAmountValue">${shockVal}</span>
          </span>
        </div>
      </div>

      <div style="display: flex; flex-direction: column;">
        ${showShockOptions ? `
      <div>
        <div id="shockToggle" style="color: rgb(143, 143, 143); cursor: pointer; margin-bottom: 10px;"
        onclick="showInheritanceOptions()">
          Advanced Settings for Inheritance ▼
        </div>
      </div>` : ''}
      
      <div id="inheritanceOptions" style="display: none;">
        ${showShockOptions ? `
        <div style="display: flex; flex-direction: column; gap: 10px; padding: 12px; border: 3px solid rgb(224, 224, 224); width: auto;">
          <label class="label-group" style="color: rgb(143, 143, 143);">Inheritance:
            <select class="inheritance-select rounded-dropdown" style="color: rgb(143, 143, 143);" data-curve="${curveName}">
              <option value="Yes">Yes</option>
              <option value="No" selected>No</option>
            </select>
          </label>
          <div style="display: flex; align-items: center; gap: 4px;">
            <label class="label-group" style="color: rgb(143, 143, 143);">Shock Parent:
              <select class="shock-parent-select rounded-dropdown" style="color: rgb(143, 143, 143);" data-curve="${curveName}" onchange="toggleParentDropdown(this)">
                <option value="Yes">Yes</option>
                <option value="No" selected>No</option>
              </select>
            </label>
            <div id="parentCurveDropdownContainer" style="display: none; margin-bottom: 10px;">
              <label style="color: rgb(143, 143, 143);">Select Parent Curve:
                <select id="parentCurveDropdown" class="rounded-dropdown" style="color: rgb(143, 143, 143);">
                  ${Array.isArray(parentCurveName) ? parentCurveName.map(p => `<option value="${p}">${p}</option>`).join('') : ''}
                </select>
              </label>
            </div>
          </div>
          <label class="label-group" style="color: rgb(143, 143, 143);">Shock Child (${childCurveName}):
            <select class="shock-child-select rounded-dropdown" style="color: rgb(143, 143, 143);" data-curve="${curveName}">
              <option value="Yes" selected>Yes</option>
              <option value="No">No</option>
            </select>
          </label>
        </div>
      ` : ''}
      </div>

      
      </div>
    </div>
  `;

      // Shock by grid point for Data Container curves
      html += `
    <div id="gridFormContainer" style="display: none;">
          <p class="text-sm text-gray-600">Grid Point form goes here.</p>
        </div>`;

      // Option to shock by grid point or bucket tenor for shock by curve name WITHOUT parent curves
      // if (currentShockBy === 'name' && Array.isArray(parentCurveName) && parentCurveName.length === 0) {
      //   html += `
      //   <div id="shockMethodContainer" style="margin-top: 8px;">
      //     <label class="label-group mt-4" style="font-weight: bold; color: #2563eb;">Shock Method:
      //       <select id="shockMethodSelect" class="rounded-dropdown" onchange="handleShockMethodChange()">
      //         <option value="tenor">Bucket Tenor</option>
      //         <option value="grid">Gridpoint Tenor</option>
      //       </select>
      //     </label>
      //   </div>
      //   <div id="gridFormContainer" style="display: none;">
      //     <p class="text-sm text-gray-600">Grid Point form goes here.</p>
      //   </div>
      // `;
      // }

      // Append tenor form container outside the flex container
      html += `
    <div id="tenorFormContainer" style="width: 100%; max-width: 100%; overflow-x: auto;">
    <div class="overflow-x-auto mt-4">
  <table id="scenarioTable" class="w-full max-w-5xl border border-gray-300 divide-y divide-gray-200 text-sm text-gray-900 rounded-md">
    <thead class="bg-gray-50">
      <tr>
        <th class="px-3 py-2 border-r border-gray-200 text-left"></th>
        <th colspan="10" class="px-3 py-2 text-center font-semibold text-gray-700 border-r border-gray-200">
          Bucket Tenor</th>
      </tr>
      <tr>
        <th class="px-3 py-2 border-r border-gray-200 text-left">Grid Name</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">3m</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">6m</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">1y</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">2y</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">3y</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">5y</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">7y</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">10y</th>
        <th class="px-3 py-2 border-r border-gray-200 text-left">20y</th>
        <th class="px-3 py-2 text-left">30y</th>
      </tr>
    </thead>
    <tbody class="divide-y divide-gray-200">
      <tr>
        <td class="px-3 py-2 border-r border-gray-200">
          <input type="text" name="GridName" value="${defaultRow[0]}" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" />
        </td>
        <td style="display: none;">
          <input type="text" name="CurveName" value="${defaultRow[1]}" />
        </td>
        ${defaultRow.slice(2).map(val => `
          <td class="px-3 py-2 border-r border-gray-200">
            <input type="number" value="${val}" class="w-full px-2 py-1 border border-gray-300 rounded text-sm text-center" />
          </td>`).join('')}
      </tr>
    </tbody>
  </table>
</div>

  <div style="display: flex; align-items:center;">
    <button onclick="addScenarioRow('${curveName}')" class="green-button" style="margin-top: 20px; margin-right: 10px;">Add Scenario</button>
    <button onclick="submitScenario('${curveName}', '${parentCurveName}', '${childCurveName}')" class="green-button" style="margin-top: 20px; margin-right: 10px;">Save</button>
    <button onclick="runSelectedCurves()" class="green-button" style="margin-top: 20px; margin-right: 10px;">Run Scenario</button>
    <p style="color: red; margin-top: 20px; margin-left: 2px; font-size: 0.9em;">(Click save before running)</p>
  </div>

    <div id="linkContainer" style="margin-top: 10px;"></div>
    </div>
  `;
      curveContent.innerHTML = html;

      // Default IR data type is decimal for data container curves
      const irTypeSelect = document.getElementById('scenarioIRDataType');
      if (irTypeSelect && type === 'Data Container') {
        irTypeSelect.value = 'decimal';
      }

      // Don't show IR Shock Type for data container curves
      if (type === 'Data Container') {
        irShockTypeContainer.style.display = 'none';
      } else {
        irShockTypeContainer.style.display = 'block';
      }

      setupShockAmountBehavior();

      // Handle shock by bucket tenor or grid point tenor for shock by curve name, curve WITHOUT parent curves
      // if (
      //   currentShockBy === 'name' &&
      //   Array.isArray(parentCurveName) &&
      //   parentCurveName.length === 0 &&
      //   document.querySelector('input[name="CurveName"]')
      // ) {
      //   handleShockMethodChange();
      // }

      const shockParentSelect = document.querySelector('.shock-parent-select');
      if (shockParentSelect && shockParentSelect.value === 'Yes') {
        toggleParentDropdown(shockParentSelect);
      }
    }

    function showInheritanceOptions() {
      const container = document.getElementById('inheritanceOptions');
      const visible = container.style.display === 'block';
      container.style.display = visible ? 'none' : 'block';
    }


    // Displays scenario generation form for shock by grid point
    async function renderGridPointScenarioForm(curveName, tenors) {
      const type = getSelectedCurveType();
      const gridForm = document.getElementById('gridFormContainer');
      gridForm.innerHTML = '';

      const container = document.createElement('div');
      container.className = 'mt-4 overflow-x-auto';

      const table = document.createElement('table');
      table.className = 'border border-gray-300 text-sm text-gray-900 rounded-md';
      table.id = 'gridScenarioTable';

      // Append correct label to Gridpoint ___ depending on data container curve type
      let suffix = 'Tenor';
      let curveCategory = '';
      if (type === 'Data Container') {
        try {
          const res = await fetch(`/api/scenario-generation/curve-category/${encodeURIComponent(curveName)}`);
          const data = await res.json();
          curveCategory = data.curveCategory;

        } catch (err) {
          console.error(err);
        }

        if (curveCategory == 'BondSpotCurve') {
          suffix = 'Cusip';
        } else if (curveCategory == 'SpotPriceCurve') {
          suffix = 'Ticker';
        } else if (curveCategory == 'ForwardPriceCurve' || curveCategory == 'FXCurve') {
          suffix = 'Tenor';
        }
      }

      const headerRow = document.createElement('tr');
      const labelCell = document.createElement('th');
      labelCell.className = 'px-3 py-2 border-r';
      labelCell.innerText = `Gridpoint ${suffix}`;
      headerRow.appendChild(labelCell);

      const scenarioNames = ['BaseCase'];
      scenarioNames.forEach((name, index) => {
        const th = document.createElement('th');
        th.className = 'px-3 py-2 border-r align-top';

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = name;
        nameInput.className = 'scenario-name-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center mb-2';

        th.appendChild(nameInput);
        headerRow.appendChild(th);
      });

      const thead = document.createElement('thead');
      thead.className = 'bg-gray-50';
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      tenors.forEach(tenor => {
        const row = document.createElement('tr');
        const tenorCell = document.createElement('td');
        tenorCell.className = 'px-3 py-2 border-r font-medium text-gray-700';
        tenorCell.innerText = tenor;
        row.appendChild(tenorCell);

        scenarioNames.forEach(() => {
          const td = document.createElement('td');
          td.className = 'px-3 py-2 border-r';
          const input = document.createElement('input');
          input.type = 'number';
          input.value = '0';
          input.className = 'grid-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center';
          td.appendChild(input);
          row.appendChild(td);
        });

        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      container.appendChild(table);

      // Create button container
      const buttonRow = document.createElement('div');
      buttonRow.style.display = 'flex';
      buttonRow.style.alignItems = 'center';
      buttonRow.style.gap = '10px';
      buttonRow.style.marginTop = '15px';

      // Add Scenario button
      const addBtn = document.createElement('button');
      addBtn.id = 'addGridPointBtn';
      addBtn.className = 'green-button';
      addBtn.innerText = 'Add Scenario';

      // Save button
      const saveBtn = document.createElement('button');
      saveBtn.className = 'green-button';
      saveBtn.innerText = 'Save';
      saveBtn.onclick = () => saveGridScenario(curveName);

      // Run button
      const runBtn = document.createElement('button');
      runBtn.className = 'green-button';
      runBtn.innerText = 'Run Scenario';
      runBtn.onclick = () => runSelectedCurves();

      // Add Scenario button logic
      addBtn.onclick = () => {
        const newColIndex = table.rows[0].cells.length - 1;

        const th = document.createElement('th');
        th.className = 'px-3 py-2 border-r align-top';

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.placeholder = 'GridName'
        nameInput.value = '';
        nameInput.className = 'scenario-name-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center mb-2';

        const fillWrapper = document.createElement('div');
        fillWrapper.className = 'flex justify-center items-center gap-1';

        const fillInput = document.createElement('input');
        fillInput.type = 'number';
        fillInput.placeholder = 'Value';
        fillInput.className = 'w-20 h-7 border border-gray-300 rounded text-sm text-center';
        fillInput.dataset.col = newColIndex;

        const fillButton = document.createElement('button');
        fillButton.className = 'green-button text-xs px-2 py-1';
        fillButton.innerText = 'Fill Column';
        fillButton.dataset.col = newColIndex;
        fillButton.onclick = () => {
          const value = fillInput.value;
          const colIndex = parseInt(fillInput.dataset.col, 10);
          const inputs = table.querySelectorAll(`tbody tr td:nth-child(${colIndex + 2}) input`);
          inputs.forEach(input => input.value = value);
        };

        fillWrapper.appendChild(fillInput);
        fillWrapper.appendChild(fillButton);

        th.appendChild(nameInput);
        th.appendChild(fillWrapper);
        table.rows[0].appendChild(th);

        // Add cells to each row
        for (let i = 1; i < table.rows.length; i++) {
          const td = document.createElement('td');
          td.className = 'px-3 py-2 border-r';
          const input = document.createElement('input');
          input.type = 'number';
          input.value = '0';
          input.className = 'grid-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center';
          td.appendChild(input);
          table.rows[i].appendChild(td);
        }
      };

      // Click save message
      const message = document.createElement('p');
      message.style.color = 'red';
      message.style.marginLeft = '6px';
      message.style.marginTop = '10px';
      message.style.fontSize = "0.9em";
      message.innerText = '(Click save before running)';
      gridForm.appendChild(message);

      // Append buttons to container
      buttonRow.appendChild(addBtn);
      buttonRow.appendChild(saveBtn);
      buttonRow.appendChild(runBtn);
      buttonRow.appendChild(message);

      // Append buttons to the grid form
      gridForm.appendChild(buttonRow);

      const viewScenario = document.createElement('div');
      viewScenario.id = 'gridLinkContainer';
      viewScenario.style.marginTop = '4px';
      gridForm.appendChild(viewScenario);

      // Fill column buttons
      const fillRow = document.createElement('div');
      fillRow.className = 'ml-8 mt-2 flex gap-4';
      gridForm.appendChild(fillRow);
      gridForm.appendChild(container);
    }


    function fillGridInputs() {
      const value = document.getElementById('fillValue').value;
      document.querySelectorAll('.grid-input').forEach(input => {
        input.value = value;
      });
    }


    function addGridPointRow(curveName, tenors) {
      const tbody = document.getElementById('gridScenarioTable').querySelector('tbody');
      const row = document.createElement('tr');
      row.innerHTML = `
    <td class="px-3 py-2 border-r">
      <input type="text" name="GridName" placeholder="GridName" class="w-full px-2 py-1 border rounded text-sm" />
    </td>
    ${tenors.map(() => `
      <td class="px-3 py-2 border-r">
        <input type="number" value="0" class="w-full px-2 py-1 border rounded text-sm text-center" />
      </td>`).join('')}
    <td class="px-3 py-2 border-l border-gray-200" style="min-width: 120px;">
      <div class="flex items-center gap-2">
        <input type="number" placeholder="Enter Value" class="fill-value-input w-auto px-2.5 py-1 bg-gray-200 border border-gray-300 rounded text-sm text-center" />
        <button onclick="fillRowWithValue(this)" class="px-2.5 py-1.5 text-white rounded text-sm" style="background-color: #2563eb;">Fill Row</button>
      </div>
    </td>
  `;
      tbody.appendChild(row);
    }

    function saveGridScenario(curveName) {
      const table = document.getElementById('gridScenarioTable');
      const headerInputs = table.querySelectorAll('thead input.scenario-name-input');
      const scenarioNames = Array.from(headerInputs).map(input => input.value.trim());
      const type = getSelectedCurveType();

      const tenorLabels = Array.from(table.querySelectorAll('tbody tr td:first-child')).map(td => td.innerText.trim());

      const rows = [];

      for (let i = 0; i < scenarioNames.length; i++) {
        const scenarioName = scenarioNames[i];
        const values = [];
        for (let j = 0; j < tenorLabels.length; j++) {
          const row = table.querySelectorAll('tbody tr')[j];
          const cell = row.querySelectorAll('td')[i + 1]; // +1 to skip tenor label
          const input = cell.querySelector('input');
          values.push(input.value.trim() || '0');
        }
        rows.push({
          GridName: scenarioName,
          CurveName: '', // not used in gridpoint format
          values
        });
      }

      let curveCategory = '';

      fetch(`/api/scenario-generation/curve-category/${encodeURIComponent(curveName)}`)
        .then(response => response.json())
        .then(data => {
          curveCategory = data.curveCategory;

          const addCurveName = type === 'Data Container' && (curveCategory == 'FXCurve' || curveCategory == 'ForwardPriceCurve');
          // Don't append curve name to scenario def file for data container curves
          const IRRiskFactors = tenorLabels.map(t => addCurveName ? `${t}${curveName}` : t).join(':');

          const scenario = {
            curveName,
            IRDataType: document.getElementById('scenarioIRDataType')?.value || 'decimal',
            IRShockType: document.getElementById('scenarioShockType')?.value || '',
            Greek: !document.getElementById('scenarioGreekToggle')?.checked ? false : true,
            IRRiskFactors,
            tenors: tenorLabels.map(t => addCurveName ? `${t}${curveName}` : t),
            rows
          };

          fetch(`/api/scenario-generation/save-scenario-def?type=${encodeURIComponent(type)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(scenario)
          })
            .then(res => res.json())
            .then(data => {
              alert(data.message);
              scenarioSaved = true;
              const linkContainer = document.getElementById('gridLinkContainer');
              linkContainer.innerHTML = `
        <a href="/api/scenario-generation/scenario.txt" target="_blank" rel="noopener noreferrer"><u>View Scenario File</u></a><br/>
      `;
            })
            .catch(err => {
              console.error('❌ Failed to save scenario:', err);
              alert('Failed to save scenario.');
            });
        })
        .catch(err => {
          console.error("Error fetching curve category:", err);
        })
    }

    // Display option to select parent curve to shock
    function toggleParentDropdown(selectElement) {
      const container = document.getElementById('parentCurveDropdownContainer');
      if (selectElement.value === 'Yes') {
        container.style.display = 'block';
      } else {
        container.style.display = 'none';
      }
    }

    // Displays forms for shock by grid point and shock by bucket tenor
    // Only for shock by curve name, curve WITHOUT parent curves
    // function handleShockMethodChange() {
    //   const method = document.getElementById('shockMethodSelect').value;
    //   const curveName = document.querySelector('input[name="CurveName"]')?.value;

    //   if (method === 'grid') {
    //     document.getElementById('gridFormContainer').style.display = 'block';
    //     document.getElementById('tenorFormContainer').style.display = 'none';
    //     fetch(`/api/scenario-generation/tenors/${curveName}`)
    //       .then(res => res.json())
    //       .then(data => renderGridPointScenarioForm(curveName, data.tenors))
    //       .catch(err => {
    //         console.error('Failed to fetch tenors:', err);
    //         alert('Could not load tenors for grid point shock.');
    //       });
    //   } else {
    //     document.getElementById('gridFormContainer').style.display = 'none';
    //     document.getElementById('tenorFormContainer').style.display = 'block';
    //   }
    // }

    // === Logic to handle Greek toggle and IR Data Type change ===
    function setupShockAmountBehavior() {
      const greekToggle = document.getElementById('scenarioGreekToggle');
      const irTypeSelect = document.getElementById('scenarioIRDataType');
      const shockAmountDisplay = document.getElementById('shockAmountDisplay');
      const shockAmountValue = document.getElementById('shockAmountValue');

      function updateShockAmountVisibility() {
        const greekOn = greekToggle.checked;
        shockAmountDisplay.style.display = greekOn ? 'inline-block' : 'none';
      }

      function updateShockAmountValue() {
        const type = irTypeSelect.value;
        const curveType = getSelectedCurveType();
        const val = curveType === 'Data Container' ? '0.01' : '0.001';
        shockAmountValue.textContent = type === 'bps' ? '10 bps' : val;
      }

      greekToggle.addEventListener('change', updateShockAmountVisibility);
      irTypeSelect.addEventListener('change', updateShockAmountValue);

      // Initialize on load
      updateShockAmountVisibility();
      updateShockAmountValue();
    }

    // Add row
    function addScenarioRow(curveName) {
      const tbody = document.getElementById('scenarioTable').querySelector('tbody');
      const row = document.createElement('tr');
      row.innerHTML = `
    <td class="px-3 py-2 border-r border-gray-200">
      <input type="text" name="GridName" placeholder="GridName" class="w-full px-2 py-1 border border-gray-300 rounded text-sm" />
    </td>
    <td style="display: none;">
      <input type="text" name="CurveName" value="${curveName}" />
    </td>
    ${['3m', '6m', '1y', '2y', '3y', '5y', '7y', '10y', '20y', '30y'].map(() => `
      <td class="px-3 py-2 border-r border-gray-200">
        <input type="number" value="0" class="w-full px-2 py-1 border border-gray-300 rounded text-sm text-center" />
      </td>
    `).join('')}
    <td class="px-3 py-2 border-l border-gray-200" style="min-width: 120px;">
      <div class="flex items-center gap-2">
        <input type="number" placeholder="Value" class="fill-value-input w-auto px-2 py-1 bg-gray-200 border border-gray-300 rounded text-sm text-center" />
        <button onclick="fillRowWithValue(this)" class="px-2.5 py-1 text-white rounded text-sm" style="background-color: #2563eb;">Fill Row</button>
      </div>
    </td>
  `;
      tbody.appendChild(row);
    }

    // Fills row in scenario generation form with value
    function fillRowWithValue(button) {
      const row = button.closest('tr');
      const value = row.querySelector('.fill-value-input').value;

      if (value === '') {
        alert('Please enter a value.');
        return;
      }

      const inputs = row.querySelectorAll('input[type="number"]');
      inputs.forEach(input => {
        input.value = value;
      });
    }

    // Save scenario -- creates scenario definition file
    // Shock by curve name with parent curve (i.e. inheritance, shock parent, child) requires diff scenario definition construction
    function submitScenario(curveName, parentCurveName = null, childCurveName = null) {
      const shockBy = currentShockBy;

      if (shockBy === 'name' && parentCurveName) {
        submitScenarioByCurveName(curveName, parentCurveName, childCurveName);
      } else {
        submitScenarioGeneral(curveName);
      }
    }

    // Send scenario definition data to backend for file construction
    function submitScenarioGeneral(curveName) {
      const IRDataType = document.getElementById('scenarioIRDataType').value;
      const IRShockType = document.getElementById('scenarioShockType').value;
      const Greek = document.getElementById('scenarioGreekToggle').checked;
      const rows = [];

      const tbody = document.getElementById('scenarioTable').querySelector('tbody');
      const trList = Array.from(tbody.querySelectorAll('tr')).slice(1); // skip BaseCase

      trList.forEach(tr => {
        const inputs = tr.querySelectorAll('input');
        const row = {
          GridName: tr.querySelector('input[name="GridName"]').value.trim(),
          CurveName: tr.querySelector('input[name="CurveName"]').value.trim(),
          values: Array.from(tr.querySelectorAll('input[type="number"]'))
            .slice(0, 10) // Only take the first 10 tenor inputs
            .map(input => input.value.trim() || '0')
        };
        rows.push(row);
      });

      // Add BaseCase manually
      rows.unshift({
        GridName: 'BaseCase',
        CurveName: curveName,
        values: Array(10).fill('0')
      });

      const scenario = {
        curveName,
        IRDataType,
        IRShockType,
        Greek,
        rows
      };

      fetch('/api/scenario-generation/save-scenario-def', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(scenario)
      })
        .then(res => res.json())
        .then(data => {
          alert(data.message);
          scenarioSaved = true;
          const linkContainer = document.getElementById('linkContainer');
          linkContainer.innerHTML = '<a href="/api/scenario-generation/scenario.txt" target="_blank" rel="noopener noreferrer"><u>View Scenario File</u></a><br/>';
        })
        .catch(err => {
          console.error('Failed to save scenario:', err);
          alert('❌ Failed to save scenario.');
        });
    }

    // Send scenario data to backend for file construction -- for shock by curve name with parent curve relationship
    function submitScenarioByCurveName(curveName, _unusedParentCurveName, childCurveName) {
      const parentCurveName = document.getElementById('parentCurveDropdown')?.value || _unusedParentCurveName;
      const IRDataType = document.getElementById('scenarioIRDataType').value;
      const IRShockType = document.getElementById('scenarioShockType').value;
      const Greek = document.getElementById('scenarioGreekToggle').checked;
      const rows = [];

      const tbody = document.getElementById('scenarioTable').querySelector('tbody');
      const trList = Array.from(tbody.querySelectorAll('tr')).slice(1); // Skip BaseCase rows

      const inheritance = document.querySelector('.inheritance-select').value === 'Yes';
      const shockParent = document.querySelector('.shock-parent-select').value === 'Yes';
      const shockChild = document.querySelector('.shock-child-select').value === 'Yes';

      // Add BaseCase rows
      if (shockParent) {
        if (inheritance) {
          // Parent before child
          rows.unshift({
            GridName: 'BaseCase',
            CurveName: childCurveName,
            values: Array(10).fill('0')
          });
          rows.unshift({
            GridName: 'BaseCase',
            CurveName: parentCurveName,
            values: Array(10).fill('0')
          });
        } else {
          // Child before parent
          rows.unshift({
            GridName: 'BaseCase',
            CurveName: parentCurveName,
            values: Array(10).fill('0')
          });
          rows.unshift({
            GridName: 'BaseCase',
            CurveName: childCurveName,
            values: Array(10).fill('0')
          });
        }
      } else {
        // Only add child if shock parent is 'No'
        rows.unshift({
          GridName: 'BaseCase',
          CurveName: childCurveName,
          values: Array(10).fill('0')
        });
      }

      // Iterate over each user-added scenario row
      trList.forEach(tr => {
        const gridName = tr.querySelector('input[name="GridName"]').value.trim();
        const values = Array.from(tr.querySelectorAll('input[type="number"]'))
          .slice(0, 10) // Only take the first 10 tenor inputs
          .map(input => input.value.trim() || '0');

        if (shockParent) {
          if (inheritance) {
            rows.push({
              GridName: gridName,
              CurveName: parentCurveName,
              values: values
            });
            rows.push({
              GridName: gridName,
              CurveName: childCurveName,
              values: shockChild ? values : Array(10).fill('0')
            });
          } else {
            rows.push({
              GridName: gridName,
              CurveName: childCurveName,
              values: shockChild ? values : Array(10).fill('0')
            });
            rows.push({
              GridName: gridName,
              CurveName: parentCurveName,
              values: values
            });
          }
        } else {
          // Only add child if shock parent is 'No'
          rows.push({
            GridName: gridName,
            CurveName: childCurveName,
            values: shockChild ? values : Array(10).fill('0')
          });
        }
      });

      const scenario = {
        curveName,
        IRDataType,
        IRShockType,
        Greek,
        rows
      };

      fetch('/api/scenario-generation/save-scenario-def', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(scenario)
      })
        .then(res => res.json())
        .then(data => {
          alert(data.message);
          scenarioSaved = true;
          // Display the link to scenario.txt
          const linkContainer = document.getElementById('linkContainer');
          linkContainer.innerHTML = `
          <a href="/api/scenario-generation/scenario.txt" target="_blank" rel="noopener noreferrer"><u>View Scenario File</u></a><br/>
          `;
        })
        .catch(err => {
          console.error('Failed to save scenario:', err);
          alert('❌ Failed to save scenario.');
        });
    }
  </script>
</body>

</html>