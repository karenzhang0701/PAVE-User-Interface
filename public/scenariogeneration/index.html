<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PAVE Scenario Generation</title>
  <link rel="icon" href="../images/manulife_logo.jpg" type="image/jpeg">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
</head>

<body>
  <div style="width: 550px;"
    class="h-screen bg-gray-50 border-r border-gray-200 p-0 flex flex-col overflow-y-auto overscroll-contain">
    <div class="items-center px-4 py-5 mb-6 w-full" style="background-color: #16a34a;">
      <div style="display: flex; align-items: center;">
        <a href="/index.html">
          <img src="../images/manulife_logo.jpg" alt="Manulife Logo" class="h-10 w-auto mr-4" />
        </a>
        <h1 class="text-xl font-semibold text-white">PAVE Scenario Generation</h1>
        <p style="font-size: 12px; color: white; margin-top: 4px; margin-left: 25px;">
          <a href="/userguides/PAVE%20Scenario%20Generation%20User%20Guide.pdf" target="_blank" class="white-button">
            User Guide
          </a>
        </p>
      </div>
      <p id="pave-version" style="font-size: 14px; color: white; margin-left: 20px; margin-top: 10px;"></p>
    </div>

    <div class="ml-6 mr-6">
      <!--Valuation Date-->
      <div id="valuationDate">
        <h3 class="quote-heading">Valuation Date</h3>
        <div>
          <div class="flex mb-4 gap-2 items-center">
            <input type="text" id="curveDate" placeholder="YYYY-MM-DD"
              class="w-40 rounded-md bg-white h-8 px-2 py-1 text-sm text-gray-900 shadow-xs ring-1 ring-gray-300 ring-inset hover:bg-gray-50 focus:outline-none" />
          </div>
        </div>
      </div>

      <div id="curveControls">
        <div class="mt-4 mb-4" id="selectedCurvesList" style="display: none;">
          <h3 class="quote-heading">Selected Curves: </h3>
          <h3 id="listCurves" class="quote-heading"></h3>
        </div>

        <div class="mb-6" id="selectedCurvesContent">
          <label class="quote-heading mt-4">Select Curve Group</label>
          <div class="relative text-gray-600 mb-4">
            <input type="search" id="curveSearch" placeholder="Search"
              class="bg-white h-8 px-5 pr-10 rounded-md text-sm w-full focus:outline-none ring-1 ring-gray-300 ring-inset hover:bg-gray-50" />
            <button type="submit" class="absolute right-0 top-0 mt-3 mr-4">
              <svg class="h-4 w-4 fill-current text-gray-500" xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 56.966 56.966">
                <path4.761,0,9.298-1.436,13.177-4.162l13.661,14.208c0.571,0.593,1.339,0.92,2.162,0.92
                  c0.779,0,1.518-0.297,2.079-0.837C56.255,54.982,56.293,53.08,55.146,51.887z
                  M23.984,6c9.374,0,17,7.626,17,17s-7.626,17-17,17 s-17-7.626-17-17S14.61,6,23.984,6z" />
              </svg>
            </button>
          </div>

          <!-- Dropdown menu of curves -->
          <select id="curveSubsetSelect" multiple size="10"
            class="w-full min-w-full rounded border-gray-300 shadow-sm text-sm h-40"
            style="border: 3px solid #16a34a;"></select>

          <button onclick="addCurveToSubset()" class="mt-2 w-full green-button">Add Curve</button>



          <!-- Selected Curves -->
          <div class="mt-4">
            <h3 class="quote-heading">Selected Curves: </h3>
            <h3 id="selectedCurveList" class="quote-heading"></h3>
            <div class="flex gap-2 mt-4 mb-2">
              <button onclick="getQuotesData()" class="flex-1 w-auto green-button text-gray-700 text-sm py-2 rounded">
                Get Quotes Data
              </button>
              <button id="resetCurveGroup" class="gray-button" onclick="resetCurveGroup()">Clear Curves</button>
            </div>
            <div id="loadingMessage" class="text-green-600 text-sm mt-1 hidden">Getting data...</div>

            <!--Displays user's selected curves for viewing definition and editing quotes-->
            <div id="selectedCurves" class="space-y-2 mt-4" style="display: block;"></div>
          </div>
        </div>

        <div id="shockOptions" style="display: block;">
          <div id="standardShock" style="display: block;">
            <!-- Shock All Button -->
            <button onclick="shockAll()" class="green-button mb-2" style="min-width: 245px;">Define Scenarios</button>

            <!-- Advanced Settings Toggle -->
            <div>
              <span id="advancedToggle" style="color: rgb(143, 143, 143); cursor: pointer;"
                onclick="toggleAdvancedSettings()">
                Advanced Settings ▼
              </span>
            </div>

            <!-- Advanced Settings Section -->
            <div id="advancedSettings"
              style="display: none; margin-top: 12px; padding: 10px; border: 3px solid rgb(224, 224, 224); width: auto;">
              <h3 class="quote-heading" style="color: rgb(143, 143, 143);">Shock By</h3>

              <!-- Shock By Curve Type Option -->
              <div id="shockCurveTypeContainer" style="display: flex; align-items: center; margin-bottom: 12px;">
                <label style="min-width: 120px; color: rgb(143, 143, 143);">
                  <input type="radio" name="shockBy" value="type" onchange="proceedToScenario()"> Curve Type
                </label>
                <div id="curveTypeSection" style="display: none; margin-left: 12px;">
                  <label for="curveTypeSelect" style="margin-right: 8px; color: rgb(143, 143, 143);">Select
                    Type:</label>
                  <select id="curveTypeSelect" class="rounded-dropdown" style="color: rgb(143, 143, 143);"
                    onchange="proceedToScenario()">
                    <option value="Bond">Bond</option>
                    <option value="YieldCurve">YieldCurve</option>
                    <option value="Surv">Surv</option>
                  </select>
                </div>
              </div>

              <!-- Shock By Curve Name Option -->
              <div id="shockByNameContainer" style="display: flex; align-items: center; margin-bottom: 12px;">
                <label style="min-width: 120px; color: rgb(143, 143, 143);">
                  <input type="radio" name="shockBy" value="name" onchange="proceedToScenario()"> Curve Name
                </label>
                <div id="curveNameSection" style="display: none; margin-left: 12px;">
                  <label for="curveNameSelect"
                    style="margin-right: 8px; color: rgb(143, 143, 143); font-weight: bold;">Select
                    Curves:</label>
                  <div id="curveNameChecklist"
                    style="color: rgb(143, 143, 143); display: flex; flex-direction: column; gap: 4px;"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div id="selectedCurves"></div>
      </div>
      <div id="missingCurvesSection" style="margin-top: 20px; color: rgb(80, 79, 79);"></div>
    </div>
  </div>

  <div id="main">
    <div id="curveContent" class="ml-4"></div>
  </div>

  <script>

    // Get last modified time of the PAVE.exe file used by the website
    window.addEventListener("DOMContentLoaded", () => {
      fetch('/api/scenario-generation/PAVE-modified-time')
        .then(res => res.json())
        .then(data => {
          const el = document.getElementById('pave-version');
          if (data.modifiedTime) {
            const date = new Date(data.modifiedTime);
            const formatted = date.toLocaleString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              second: '2-digit',
              hour12: true
            });
            el.textContent = 'PAVE Engine Version: ' + formatted;
          } else {
            el.textContent = 'PAVE Engine Version: Not available';
          }
        })
        .catch(() => {
          document.getElementById('pave-version').textContent = 'PAVE Engine Version: Error fetching data';
        });
    });

    let currentShockBy = 'type'; // selected shock method (curve type, curve name, all)
    let scenarioSaved = false;
    const selectedCurvesDiv = document.getElementById('selectedCurves'); // div where selected curves are displayed
    const curveContent = document.getElementById('curveContent'); // right side page (displays scenario generation form)
    const curveSubsetSelect = document.getElementById('curveSubsetSelect'); // dropdown menu of curves
    const selectedCurves = new Set(); // tracks selected curves
    let pendingUpdates = []; // stores scenario form edits
    let missingCurves = []; // curves with no quotes data
    let shockByCurveNameSet = new Set(); // selected curves for shock by curve name


    // Checks if curve manager finished getting quotes data and copies it once ready
    async function copyCurveManagerData() {
      try {
        const checkInterval = setInterval(async () => {
          const response = await fetch('/api/scenario-generation/isCurveManagerPopulated');
          const data = await response.json();

          if (data.populated) {
            clearInterval(checkInterval);

            // Copy curve manager data to scenario generation file (CDef_ScenarioGroup.txt and CQuotes_ScenarioGroup.txt)
            const copyResponse = await fetch('/api/scenario-generation/copyCurveManagerData', {
              method: 'POST',
            });
            const copyData = await copyResponse.json();
            console.log('✅', copyData.message);
          }
        }, 100);
      } catch (error) {
        console.error('❌ Error during curve manager data check/copy:', error);
      }
    }

    let dealsManager = false;

    // Receive discount and projection curves, and valuation date from Deals Manager
    window.addEventListener('message', async (event) => {
      if (event.data?.type === 'loadCurves') {
        dealsManager = true;

        const { curves, valuationDate } = event.data;

        // Add discount and projection curves to selectedCurves set
        selectedCurves.clear();
        resetCurveGroup();
        curves.forEach(curve => selectedCurves.add(curve));
        populateCurveChecklist(selectedCurves); // populates options for shock by curve name

        document.getElementById('curveDate').value = valuationDate;
        document.getElementById('valuationDate').style.display = 'none';
        document.getElementById('selectedCurvesContent').style.display = 'none';
        document.getElementById('listCurves').textContent = curves.join(', ');
        document.getElementById('selectedCurvesList').style.display = 'block';

        // Wait for curve manager data and copy it to scenario group
        await copyCurveManagerData();
      }
    });

    window.onload = function () {
      resetCurveGroup();
      populateCurveDropdown();
    }

    // Store user's input date
    let selectedDate = ''
    document.getElementById('curveDate').addEventListener('input', (e) => {
      selectedDate = e.target.value;
    });

    const irpdfNames = new Set([
      'FX_JPY.USD', 'FX_USD.AUD'
    ]);

    const dataContainerNames = new Set([
      'BOND_PRICES.CAD', 'BOND_PRICES.JPY', 'BOND_PRICES.USD',
      'MarketPX.CAD', 'MarketPX.JPY', 'MarketPX.USD',
      'FX_CAD.USD', 'FX_JPY.USD', 'FX_SGD.USD', 'FX_USD.AUD',
      'FX_USD.EUR', 'FX_USD.GBP', 'FX_USD.NZD',
      'IBOXUSHY.USD', 'MFCPRIndx.CAD'
    ]);

    const CPINames = new Set(['CPI.CAD', 'CPI.USD']);

    let IRRiskFactors = '';
    let EQRiskFactors = '';

    // Populates curve name options for shock by curve name
    function populateCurveChecklist(curveNames) {
      shockByCurveNameSet.clear();
      const checklistContainer = document.getElementById('curveNameChecklist');
      checklistContainer.innerHTML = '';

      curveNames.forEach(name => {
        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '6px';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = name;
        checkbox.onchange = (event) => {
          const isChecked = event.target.checked;

          if (isChecked) {
            shockByCurveNameSet.add(name);
          } else {
            shockByCurveNameSet.delete(name);
          }

          fetch('/api/scenario-generation/tenors', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ curves: Array.from(shockByCurveNameSet), shock: 'Curve Name' })
          })
            .then(res => res.json())
            .then(data => {
              console.log(data.curves);

              // Put IR curves before EQ
              const orderedCurves = [
                ...data.curves.filter(curve => curve.type === 'IR'),
                ...data.curves.filter(curve => curve.type === 'EQ')
              ];

              // Separate IR and EQ tenors
              const IR = [];
              const EQ = [];

              data.curves.forEach(curve => {
                if (curve.type === 'IR') {
                  IR.push(...curve.tenors);
                } else if (curve.type === 'EQ') {
                  EQ.push(...curve.tenors);
                }
              });

              // Join risk factors
              IRRiskFactors = IR.join(':');
              EQRiskFactors = EQ.join(':');

              // Ensure IR tenors come first
              const allTenors = [...IR, ...EQ];
              console.log("ORDERED CURVES");
              console.log(orderedCurves);
              renderScenarioForm('Curve Name', '', '', allTenors);
              renderGridPointScenarioForm('name', orderedCurves);
            });
        }

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(name));
        checklistContainer.appendChild(label);
      });
    }


    // Populates dropdown with list of all curves for specific curve class
    function populateCurveDropdown() {
      const curveSelect = document.getElementById('curveSubsetSelect');

      curveSelect.innerHTML = '';

      fetch(`/api/scenario-generation/all-curve-names`)
        .then(res => res.json())
        .then(curves => {
          curves.forEach(name => {
            const option = document.createElement('option');
            option.textContent = name;
            curveSelect.appendChild(option);
          });
        })
        .catch(err => {
          console.error('❌ Failed to fetch curves:', err);
        });
    }

    // Updates CDef_ScenarioGroup.txt for each curve user selects
    function addCurveToSubset() {
      const selected = Array.from(curveSubsetSelect.selectedOptions).map(opt => opt.value);
      selected.forEach(name => selectedCurves.add(name));

      document.getElementById('selectedCurveList').textContent = Array.from(selectedCurves).join(', ');

      const curves = Array.from(selectedCurves);

      fetch('/api/scenario-generation/generate-selected-curves-def', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ curves })
      })
        .then(res => res.json())
        .then(data => {
          console.log('✅ Curve group saved:', data.message);
        })
        .catch(err => {
          console.error('❌ Failed to generate master files:', err);
        });
    }

    // Filter dropdown options based on user input
    document.getElementById('curveSearch').addEventListener('input', function () {
      const searchTerm = this.value.toLowerCase();
      const options = curveSubsetSelect.options;
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        const text = option.textContent.toLowerCase();
        option.style.display = text.includes(searchTerm) ? '' : 'none';
      }
    });

    // Resets selected curve group
    function resetCurveGroup() {
      document.getElementById("selectedCurves").innerHTML = "";
      document.getElementById("selectedCurveList").innerHTML = "";
      document.getElementById("curveContent").innerHTML = "";
      selectedCurvesDiv.style.display = 'block';

      selectedCurves.clear();
      shockByCurveNameSet.clear();

      const advancedOptions = document.querySelectorAll('input[name="shockBy"]');
      advancedOptions.forEach(option => option.checked = false);

      const advancedSettings = document.getElementById('advancedSettings');
      advancedSettings.style.display = 'none';

      fetch('/api/scenario-generation/clear-curve-files', {
        method: 'POST'
      })
        .then(res => res.json())
        .then(data => {
          if (data.status === 'success') {
            console.log('✅ Curve group reset.');
          } else {
            alert('⚠️ Failed to reset curve group: ' + data.message);
          }
        })
        .catch(err => {
          console.error('❌ Error resetting curve group:', err);
          alert('❌ Error resetting curve group.');
        })
    }

    // Show advanced shock methods (curve type, curve name) when user clicks Advanced Settings
    function toggleAdvancedSettings() {
      const section = document.getElementById('advancedSettings');
      section.style.display = section.style.display === 'none' ? 'block' : 'none';
    }

    // Display scenario from when user clicks 'Shock All' button
    function shockAll() {
      currentShockBy = 'ALL';
      shockByCurveNameSet.clear();
      selectedCurvesDiv.style.display = 'none';
      const advancedOptions = document.querySelectorAll('input[name="shockBy"]');
      advancedOptions.forEach(option => option.checked = false);

      console.log("SELECTED CURVES:");
      console.log(selectedCurves);

      // Separate IR and EQ curves
      const IR_Curves = [];
      const EQ_Curves = [];

      selectedCurves.forEach(curve => {
        if (!dataContainerNames.has(curve)) {
          IR_Curves.push(curve);
        } else {
          EQ_Curves.push(curve);
        }
      })

      const curvesToSend = [...EQ_Curves];
      if (IR_Curves.length > 0) {
        curvesToSend.push('Selected IR Curves');
      }

      // Get gridpoints and bucket tenors for selected curves
      fetch('/api/scenario-generation/tenors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ curves: curvesToSend, shock: 'ALL' })
      })
        .then(res => res.json())
        .then(data => {
          console.log(data.curves);

          // Put IR curves before EQ
          const orderedCurves = [
            ...data.curves.filter(curve => curve.type === 'IR'),
            ...data.curves.filter(curve => curve.type === 'EQ')
          ];

          // Separate IR and EQ tenors
          const IR = [];
          const EQ = [];

          data.curves.forEach(curve => {
            if (curve.type === 'IR') {
              IR.push(...curve.tenors);
            } else if (curve.type === 'EQ') {
              EQ.push(...curve.tenors);
            }
          });

          // Join risk factors
          IRRiskFactors = IR.join(':');
          EQRiskFactors = EQ.join(':');

          // Ensure IR tenors come first
          const allTenors = [...IR, ...EQ];

          renderScenarioForm('ALL', '', '', allTenors);
          renderGridPointScenarioForm('ALL', orderedCurves);
        });
    }

    // Fetch quotes data for selected curves and display view definition, edit quotes options for each curve
    function getQuotesData() {
      document.getElementById('loadingMessage').classList.remove('hidden');
      const date = document.getElementById('curveDate').value;

      if (!date) {
        alert('Please enter a valuation date.');
        document.getElementById('loadingMessage').classList.add('hidden');
        return;
      }

      fetch('/api/scenario-generation/generate-quotes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ date })
      })
        .then(res => res.json())
        .then(data => {
          missingCurves = data.missingCurves;
          if (missingCurves && missingCurves.length > 0) {
            alert(`⚠️ Curves without data for ${date}:\n\n` + missingCurves.join('\n'));
          } else {
            alert('✅ Quotes data generated successfully.');
          }
          document.getElementById('loadingMessage').classList.add('hidden');

          const selectedCurvesDiv = document.getElementById('selectedCurves');

          fetch('/api/scenario-generation/quotes-curve-list')
            .then(res => res.json())
            .then(data => {
              const curves = data.curves || [];

              curves.forEach(name => {
                const div = document.createElement('div');
                div.className = 'curve-item';
                div.innerHTML = `
              <div style="margin-top: 5px; margin-bottom: 5px;">
                <strong>${name}</strong><br/>
                <div class="flex mt-2">
                  <nav class="flex overflow-x-auto items-center p-1 space-x-1 text-sm text-gray-600 bg-gray-100 rounded-xl">
                    <button type="button"
                      onclick="viewDefinition('${name}')"
                      class="whitespace-nowrap flex items-center h-8 px-4 font-medium rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400">
                      View Definition
                    </button>
                    <button
  type="button"
  onclick="handleEditQuotes('${name}')"
  class="whitespace-nowrap flex items-center h-8 px-4 font-medium rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400"
>
  Edit Quotes
</button>
                  </nav>
                </div>
                <div id="parents-${name}" style="margin-top: 5px; font-size: 0.9em; color: #555;"></div>
              </div>
            `;
                selectedCurvesDiv.appendChild(div);

                // Fetch and display parent curves
                fetch(`/api/scenario-generation/parents/${name}`)
                  .then(res => res.json())
                  .then(data => {
                    const parentText = data.parents?.length
                      ? `Parent Curves: ${data.parents.join(', ')}`
                      : 'Parent Curves: None';
                    document.getElementById(`parents-${name}`).textContent = parentText;
                  })
                  .catch(err => console.error(`Failed to fetch parents for ${name}:`, err));
              });

              populateCurveChecklist(curves);

              document.getElementById('selectedCurveList').textContent = curves.join(', ');
            })
            .catch(err => {
              console.error('❌ Failed to fetch curve list:', err);
              document.getElementById('loadingMessage').classList.add('hidden');
              alert('❌ Failed to fetch curve list.');
            });
        })
        .catch(err => {
          console.error('❌ Failed to get quotes data:', err);
          alert('❌ Failed to get quotes data.');
        });
    }

    // Call corresponding editing quotes function depending on curve type
    function handleEditQuotes(name) {
      if (CPINames.has(name)) {
        viewCPIQuotes(name);
      } else if (dataContainerNames.has(name) || irpdfNames.has(name)) {
        viewDataContainerIRPDFQuotes(name);
      } else {
        editSwapBondQuotes(name);
      }
    }

    // Display curve's definition file
    function viewDefinition(curveName) {
      fetch(`/api/scenario-generation/definition/${curveName}`)
        .then(res => res.text())
        .then(data => {
          curveContent.innerHTML = `<h3 class="text-lg font-semibold text-gray-800 mb-2">${curveName} - Definition</h3><pre>${data}</pre>`;
        });
    }

    // Creates unique indentifiers for each row of quote data, used to match edited quotes with corresponding original values
    function generateRowKey(row) {
      const keyParts = [];
      for (const [k, v] of Object.entries(row)) {
        if (isNaN(v) || v === '') {
          keyParts.push(v?.trim());
        }
        if (keyParts.length >= 2) break;
      }
      return keyParts.join('_');
    }

    // Display quotes table for Data Container and IRPDF curves
    function viewDataContainerIRPDFQuotes(curveName) {
      pendingUpdates = [];

      Promise.all([
        fetch(`/api/scenario-generation/quotes/${curveName}`).then(res => res.text()),
        fetch(`/api/scenario-generation/original-quotes/${curveName}`).then(res => res.text())
      ]).then(([editableData, originalData]) => {
        const parseCurveBlock = (data) => {
          const blocks = data.split('#BeginCurve').filter(Boolean);
          return blocks.map(block => {
            const lines = block.trim().split('\n');
            const nameLine = lines.find(line => line.startsWith('CurveName'));
            const curve = nameLine ? nameLine.split(/\s+/)[1] : 'Unknown';
            const quoteStart = lines.findIndex(line => line.includes('///:CurveMarketQuotes'));
            if (quoteStart === -1) return null;

            const headers = lines[quoteStart + 1].trim().split('\t');
            const rows = [];

            for (let i = quoteStart + 3; i < lines.length; i++) {
              const line = lines[i].trim();
              if (line.startsWith('#EndCurve') || line === '') break;
              const values = line.split('\t');
              const row = {};
              headers.forEach((h, idx) => row[h] = values[idx] ?? '');
              rows.push(row);
            }

            return { curveName: curve, headers, rows };
          }).filter(Boolean);
        };

        const editableBlocks = parseCurveBlock(editableData);
        const originalBlocks = parseCurveBlock(originalData);

        const targetBlock = editableBlocks.find(b => b.curveName === curveName);
        const originalBlock = originalBlocks.find(b => b.curveName === curveName);

        if (!targetBlock || targetBlock.rows.length === 0) {
          curveContent.innerHTML = `<h3 class="quote-heading">${curveName} - Quotes</h3><p>No quotes data available.</p>`;
          return;
        }

        const originalMap = new Map();
        originalBlock?.rows.forEach(row => {
          const key = generateRowKey(row);
          originalMap.set(key, row);
        });

        const numericFields = new Set();
        targetBlock.rows.forEach(row => {

          Object.entries(row).forEach(([key, val]) => {
            if (!isNaN(val) && /^\d+(\.\d+)?$/.test(val)) {
              numericFields.add(key);
            }
          });
        });

        let adjustFieldOptions = '';
        [...numericFields].forEach(field => {
          const label = field === 'Rate' ? 'Rate (decimal)' : `${field}`;
          adjustFieldOptions += `<option value="${field}">${label}</option>`;
        });
        const isBondCurve = curveName.startsWith('BOND_PRICES');

        let html = `
      <h3 class="text-lg font-semibold text-gray-800 mb-2">${curveName} - Quotes</h3>
    `;

        html += `
        <div id="adjustAllContainer" class="mt-4">
          <strong class="block text-sm font-semibold text-gray-700 mb-2">Adjust Input:</strong>
          <div class="flex flex-wrap gap-2 mb-3">
            <select id="adjustField" class="px-2 py-1 text-sm text-gray-700 border rounded">
              ${adjustFieldOptions}
            </select>
            <select id="adjustOp" class="px-2 py-1 text-sm text-gray-700 border rounded">
              <option value="+">+</option>
              <option value="-">-</option>
            </select>
            <input type="number" id="adjustValue" step="0.0001" placeholder="Enter value"
              class="px-2 py-1 text-sm text-gray-700 border rounded w-28" />
            <button onclick="adjustAllQuotes()" class="blue-button">Apply</button>
          </div>
          <button class="green-button mb-4" onclick="saveAllChanges()">Save Changes</button>
        </div>
      `;

        html += `
      <div class="quote-block" data-curve="${curveName}" data-source="${curveName}">
        <div class="overflow-x-auto">
          <table class="w-auto max-w-5xl border border-gray-300 divide-y divide-gray-200 text-sm text-gray-900 mb-6 rounded-md">
            <thead class="bg-gray-50">
              <tr>
                ${targetBlock.headers.map(h => `<th class="px-3 py-2 border-r border-gray-200 text-left">${h}</th>`).join('')}
                ${!isBondCurve ? targetBlock.headers.map(h => numericFields.has(h) ? `<th class="px-3 py-2 border-r border-gray-200 text-left">Original ${h}</th>` : '').join('') : ''}
              </tr>
            </thead>
            <tbody class="divide-y divide-gray-200">
    `;

        targetBlock.rows.forEach(row => {
          const key = generateRowKey(row);
          const original = originalMap.get(key) || {};
          html += `<tr>`;
          targetBlock.headers.forEach(h => {
            const val = row[h] ?? '';
            const editable = !isNaN(val) && /^\d+(\.\d+)?$/.test(val) && val.toUpperCase() != 'NULL'; // user can't edit NULL and non-numeric fields
            html += `<td class="px-3 py-2 border-r border-gray-200" ${editable ? `contenteditable="true" data-field="${h}" onblur="trackEdit('${curveName}', '${h}', this)"` : ''}>${val}</td>`;
          });
          if (!isBondCurve) {
            targetBlock.headers.forEach(h => {
              if (numericFields.has(h)) {
                html += `<td class="px-3 py-2 border-r border-gray-200 text-gray-500">${original[h] ?? ''}</td>`;
              }
            });
          }
          html += `</tr>`;
        });

        html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

        curveContent.innerHTML = html;
      });
    }

    // Display quotes table for CPI curves
    function viewCPIQuotes(curveName) {
      Promise.all([
        fetch(`/api/scenario-generation/cpi-quotes/${curveName}`).then(res => res.json()),
        fetch(`/api/scenario-generation/original-cpi-quotes/${curveName}`).then(res => res.json())
      ])
        .then(([editable, original]) => {
          const originalMap = new Map(original.historicalCPI.map(r => [r.date, r.rate]));
          const seasonMap = new Map(original.seasonalityRate.map(r => [r.month, r.rate]));
          const zcisMap = new Map(original.zcis.map(r => [r.years, r.yield]));

          let html = `
      <h3 class="text-lg font-semibold text-gray-800 mb-4">${curveName} - CPI Quotes</h3>
      <button class="green-button mb-6" onclick="saveCPIChanges('${curveName}')">Save Changes</button>

      <h4 class="font-bold mb-2">Historical CPI</h4>
      <table class="w-auto text-sm border border-gray-300 mb-6">
        <thead class="bg-gray-100">
          <tr>
            <th class="px-3 py-2 border">Date</th>
            <th class="px-3 py-2 border">Original Rate</th>
            <th class="px-3 py-2 border">Edit Rate</th>
          </tr>
        </thead>
        <tbody>
          ${editable.historicalCPI.map(row => {
            const orig = originalMap.get(row.date) ?? 'N/A';
            return `<tr>
              <td class="px-3 py-2 border">${row.date}</td>
              <td class="px-3 py-2 border bg-gray-100">${orig}</td>
              <td class="px-3 py-2 border" contenteditable="true" onblur="this.style.backgroundColor='#ffffcc'">${row.rate}</td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>

      <h4 class="font-bold mb-2">Seasonality Rate</h4>
      <table class="w-full text-sm border border-gray-300 mb-6">
        <thead class="bg-gray-100">
          <tr>
            <th class="px-3 py-2 border">Month</th>
            <th class="px-3 py-2 border">Original Rate</th>
            <th class="px-3 py-2 border">Edit Rate</th>
          </tr>
        </thead>
        <tbody>
          ${editable.seasonalityRate.map(row => {
            const orig = seasonMap.get(row.month) ?? 'N/A';
            return `<tr>
              <td class="px-3 py-2 border">${row.month}</td>
              <td class="px-3 py-2 border bg-gray-100">${orig}</td>
              <td class="px-3 py-2 border" contenteditable="true" onblur="this.style.backgroundColor='#ffffcc'">${row.rate}</td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>

      <h4 class="font-bold mb-2">Zero Coupon Inflation Swap (ZCIS)</h4>
      <table class="w-full text-sm border border-gray-300 mb-6">
        <thead class="bg-gray-100">
          <tr>
            <th class="px-3 py-2 border">Years</th>
            <th class="px-3 py-2 border">Original Yield</th>
            <th class="px-3 py-2 border">Edit Yield</th>
          </tr>
        </thead>
        <tbody>
          ${editable.zcis.map(row => {
            const orig = zcisMap.get(row.years) ?? 'N/A';
            return `<tr>
              <td class="px-3 py-2 border">${row.years}</td>
              <td class="px-3 py-2 border bg-gray-100">${orig}</td>
              <td class="px-3 py-2 border" contenteditable="true" onblur="this.style.backgroundColor='#ffffcc'">${row.yield}</td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>
    `;

          document.getElementById('curveContent').innerHTML = html;
        })
        .catch(err => {
          console.error('Failed to load CPI quotes:', err);
          alert('Error loading CPI quotes.');
        });
    }

    // Send CPI quotes changes to backend
    function saveCPIChanges(curveName) {
      const tables = document.querySelectorAll('#curveContent table');
      const [histTable, seasonTable, zcisTable] = tables;

      const historicalCPI = Array.from(histTable.rows).slice(1).map(row => ({
        date: row.cells[0].innerText.trim(),
        rate: parseFloat(row.cells[2].innerText.trim())
      }));

      const seasonalityRate = Array.from(seasonTable.rows).slice(1).map(row => ({
        month: row.cells[0].innerText.trim(),
        rate: parseFloat(row.cells[2].innerText.trim())
      }));

      const zcis = Array.from(zcisTable.rows).slice(1).map(row => ({
        years: parseFloat(row.cells[0].innerText.trim()),
        yield: parseFloat(row.cells[2].innerText.trim())
      }));

      fetch(`/api/scenario-generation/save-cpi-quotes/${curveName}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ historicalCPI, seasonalityRate, zcis })
      })
        .then(res => res.json())
        .then(data => {
          alert(data.message || '✅ Changes saved!');
        })
        .catch(err => {
          console.error('❌ Failed to save CPI changes:', err);
          alert('Failed to save changes.');
        });
    }

    // Allow user to edit rate and spread values in table format
    function editSwapBondQuotes(curveName) {
      const ALMNames = new Set([
        'USD_Public_BB', 'Treasury_USD'
      ]);
      const isALM = ALMNames.has(curveName);
      pendingUpdates = [];

      Promise.all([
        fetch(`/api/scenario-generation/quotes/${curveName}`).then(res => res.text()),
        fetch(`/api/scenario-generation/original-quotes/${curveName}`).then(res => res.text())
      ]).then(([editableData, originalData]) => {

        const parseMultipleCurveBlocks = (data) => {
          const blocks = data.split('#BeginCurve').filter(Boolean);
          return blocks.map(block => {
            const lines = block.split('\n');
            const nameLine = lines.find(line => line.startsWith('CurveName'));
            const curve = nameLine ? nameLine.split(/\s+/)[1] : 'Unknown';

            let startIndex = lines.findIndex(line => line.includes('///:CurveMarketQuotes'));
            let isALMBlock = false;
            if (startIndex === -1) {
              startIndex = lines.findIndex(line => line.includes('///:CurveDefinition'));
              isALMBlock = true;
            }

            const rows = [];
            for (let i = startIndex + 3; i < lines.length; i++) {
              const line = lines[i].trim();
              if (line.startsWith('#EndCurve') || line === '') break;
              const parts = line.split(/\s+/);
              if (parts.length >= 4) {
                const row = {
                  SecType: parts[0],
                  Tenor: parts[1],
                  Rate: parts[2],
                  Spread: parts[3],
                };

                if (parts.length > 4) {
                  row.CustomizedSpread = parts[4];
                }

                rows.push(row);
              }
            }

            return { curveName: curve, rows };
          });
        };

        const editableBlocks = parseMultipleCurveBlocks(editableData);
        const originalBlocks = parseMultipleCurveBlocks(originalData);

        // Map original values for comparison
        const originalMap = {};
        originalBlocks.forEach(block => {
          block.rows.forEach(row => {
            originalMap[`${block.curveName}_${row.SecType}_${row.Tenor}`] = row;
          });
        });

        // Only show quotes for selected curve (exclude parent curves)
        const targetBlock = editableBlocks.find(block => block.curveName === curveName);
        if (!targetBlock || targetBlock.rows.length === 0) {
          curveContent.innerHTML = `<h3 class="quote-heading">${curveName} - Quotes</h3><p>No quotes data available.</p>`;
          return;
        }

        // Detect numeric fields for adjust input columns
        const numericFields = new Set();
        targetBlock.rows.forEach(row => {
          Object.entries(row).forEach(([key, val]) => {
            if (!isNaN(val) && /^\d+(\.\d+)?$/.test(val)) {
              numericFields.add(key);
            }
          });
        });

        let adjustFieldOptions = '';
        [...numericFields].forEach(field => {
          const label = field === 'Rate' ? 'Rate (decimal)' : `${field} (bps)`;
          adjustFieldOptions += `<option value="${field}">${label}</option>`;
        });

        let html = `
        <h3 class="text-lg font-semibold text-gray-800 mb-2">${curveName} - Quotes</h3>
      <div id="adjustAllContainer" class="mt-4">
        <strong class="block text-sm font-semibold text-gray-700 mb-2">Adjust Input:</strong>
        <div class="flex flex-wrap gap-2 mb-3">
          <select id="adjustField" class="px-2 py-1 text-sm text-gray-700 border rounded">
            ${adjustFieldOptions}
          </select>
          <select id="adjustOp" class="px-2 py-1 text-sm text-gray-700 border rounded">
            <option value="+">+</option>
            <option value="-">-</option>
          </select>
          <input type="number" id="adjustValue" step="0.0001" placeholder="Enter value"
            class="px-2 py-1 text-sm text-gray-700 border rounded w-28" />
          <button onclick="adjustAllQuotes()" class="blue-button">Apply</button>
        </div>
        <button class="green-button mb-4" onclick="saveAllChanges()">Save Changes</button>
      </div>
      <div class="quote-block" data-curve="${curveName}" data-source="${curveName}">
        <div class="overflow-x-auto">
        <table class="w-auto max-w-5xl border border-gray-300 divide-y divide-gray-200 text-sm text-gray-900 mb-6 rounded-md">
          <thead class="bg-gray-50">
            <tr>
              <th class="px-3 py-2 border-r border-gray-200 text-left">SecType</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Tenor</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Original Rate</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Edit Rate</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Original ${isALM ? 'MarketSpread' : 'Spread'}</th>
              <th class="px-3 py-2 border-r border-gray-200 text-left">Edit ${isALM ? 'MarketSpread' : 'Spread'}</th>
              ${isALM ? '<th class="px-3 py-2 border-r border-gray-200 text-left">Original CustomizedSpread</th>' : ''}
              ${isALM ? '<th class="px-3 py-2 text-left">Edit CustomizedSpread</th>' : ''}
            </tr>
          </thead>
          <tbody class="divide-y divide-gray-200">
    `;

        targetBlock.rows.forEach(row => {
          const key = `${curveName}_${row.SecType}_${row.Tenor}`;
          const original = originalMap[key] || { Rate: 'N/A', Spread: 'N/A', CustomizedSpread: '0' };

          html += `<tr>
        <td class="px-3 py-2 border-r border-gray-200">${row.SecType}</td>
        <td class="px-3 py-2 border-r border-gray-200">${row.Tenor}</td>
        <td class="px-3 py-2 border-r border-gray-200 bg-gray-100">${original.Rate}</td>
        <td class="px-3 py-2 border-r border-gray-200" data-field="Rate" 
        ${row.Rate?.toUpperCase() !== 'NULL' ? 'contenteditable="true"' : ''}
    onblur="trackEdit('${curveName}', 'Rate', this)">
    ${row.Rate}
</td>
<td class="px-3 py-2 border-r border-gray-200 bg-gray-100">${original.Spread}</td>
<td class="px-3 py-2 border-r border-gray-200" data-field="Spread" 
${row.Spread?.toUpperCase() !== 'NULL' ? 'contenteditable="true"' : ''}
    onblur="trackEdit('${curveName}', 'Spread', this)">
    ${row.Spread}
</td>
${isALM ? `<td class="px-3 py-2 border-r border-gray-200 bg-gray-100">${original.CustomizedSpread}</td>` : ''}
${isALM ? `<td class="px-3 py-2" data-field="CustomizedSpread" 
${row.CustomizedSpread?.toUpperCase() !== 'NULL' ? 'contenteditable="true"' : ''}
    onblur="trackEdit('${curveName}', 'CustomizedSpread', this)">
    ${row.CustomizedSpread}
</td>` : ''}
      </tr>`;
        });

        html += `
          </tbody>
        </table>
      </div>
    `;

        curveContent.innerHTML = html;
      });
    }

    // Add or subtract values for entire column of specific curve
    function adjustAllQuotes() {
      const field = document.getElementById('adjustField').value;
      const curve = document.querySelector('.quote-block')?.getAttribute('data-curve');
      const operation = document.getElementById('adjustOp').value;
      const value = new Decimal(document.getElementById('adjustValue').value);


      if (value.isNaN()) {
        alert('Please enter a valid number.');
        return;
      }

      const blocks = document.querySelectorAll(`.quote-block[data-curve="${curve}"]`);
      blocks.forEach(block => {
        const sourceCurve = block.getAttribute('data-source');
        const rows = block.querySelectorAll('tbody tr');

        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          const secType = cells[0].innerText.trim();
          const tenor = cells[1].innerText.trim();
          const isParent = curve !== sourceCurve;

          const ALMNames = new Set([
            'USD_Public_BB', 'Treasury_USD'
          ]);
          const isALM = ALMNames.has(curve);

          // ALM Curves: Convert Spread to MktSpread for editing backend file
          const normalizedField = isALM && field === 'Spread' ? 'MktSpread' : field;
          let targetCell = Array.from(row.querySelectorAll('td')).find(td => td.getAttribute('data-field') === field);

          console.log(`Trying to adjust ${normalizedField} for ${curve}, ${secType}, ${tenor}`);
          console.log('Found cell:', targetCell);


          if (!targetCell) return;

          const rawValue = targetCell.innerText.trim();
          if (rawValue.toUpperCase() === 'NULL' || rawValue === '') return;

          const currentValue = new Decimal(rawValue);

          if (!currentValue.isNaN()) {
            const newValue = operation === '+' ? currentValue.plus(value) : currentValue.minus(value);
            targetCell.innerText = newValue.toString();
            trackEdit(curve, normalizedField, targetCell);
          }
        });
      });
    }


    // Tracks changes made to quote fields -- sends index of edited row to backend for updating txt file
    function trackEdit(curveName, field, cell) {
      const row = cell.closest('tr');
      const rowIndex = Array.from(row.parentNode.children).indexOf(row);
      const newValue = cell.innerText.trim();
      const sourceCurve = document.querySelector('.quote-block[data-curve]')?.getAttribute('data-source') || curveName;

      pendingUpdates.push({
        curveName,
        rowIndex,
        field,
        newValue,
        sourceCurve
      });

      cell.style.backgroundColor = '#ffffcc';
    }

    // Saves quote data changes
    function saveAllChanges() {
      if (pendingUpdates.length === 0) {
        alert('No changes to save.');
        return;
      }

      const updatesByFile = {};
      pendingUpdates.forEach(update => {
        const file = update.sourceCurve;
        if (!updatesByFile[file]) updatesByFile[file] = [];
        updatesByFile[file].push(update);
      });

      const requests = Object.entries(updatesByFile).flatMap(([fileCurve, updates]) =>
        updates.map(update =>
          fetch(`/api/scenario-generation/save-quote-changes/${update.curveName}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ...update, sourceCurve: fileCurve })
          })
        )
      );

      Promise.all(requests)
        .then(() => {
          alert('✅ All changes saved!');
          pendingUpdates = [];
          document.querySelectorAll('td[contenteditable]').forEach(td => td.style.backgroundColor = '');
        })
        .catch(err => {
          console.error('❌ Failed to save changes:', err);
          alert('Some changes failed to save.');
        });
    }

    // Run PAVE
    function runSelectedCurves() {
      const outputContainer = document.getElementById('scenarioOutputContainer');
      outputContainer.innerHTML = '';

      if (!scenarioSaved) {
        alert('⚠️ Save scenario before running');
        return;
      }

      const curves = Array.from(selectedCurves);
      const valuationDate = document.getElementById('curveDate').value;

      // Display Running message
      const msg = document.getElementById('runningMessage');
      if (msg) {
        msg.textContent = 'Running...';
      }

      fetch('/api/scenario-generation/run-scenario-generation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ valuationDate })
      })
        .then(res => res.json())
        .then(results => {
          scenarioSaved = false;
          document.getElementById('viewOutputBtn').style.display = 'block';
          viewOutputBtn.onclick = () => {
            document.getElementById('scenarioOutputContainer')?.scrollIntoView({ behavior: 'smooth' });
          };

          if (Array.isArray(results) && results.length > 0) {
            const result = results[0];
            outputContainer.innerHTML += `
  <hr class="h-4 border-gray-300 mb-4" />
  <div class="flex items-center justify-between gap-6 mb-2">
    <h2 class="output-heading">Output</h2>
    <button id="backToScenarioBtn" class="text-blue-600 font-bold text-base underline hover:text-blue-800">
      Back to Scenarios ↑
    </button>
  </div>
  <div class="flex gap-2 mb-6">
    <a href="/api/scenario-generation/download/scenarioOutput" download>
      <button class="blue-button mt-2 mb-2">Download Output</button>
    </a>
    <a href="/api/scenario-generation/download/scenarioQuotes" download>
      <button class="blue-button mt-2 mb-2">Download Quotes</button>
    </a>
    <a href="/api/scenario-generation/download/curveDef" download>
      <button class="blue-button mt-2 mb-2">Download Curve Def</button>
    </a>
    <a href="/api/scenario-generation/download/scenarioDefinition" download>
      <button class="blue-button mt-2 mb-2">Download Scenario Def</button>
    </a>
  </div>

  <div class="flex gap-6 mt-4">
    <div class="flex-1">
      <pre class="bg-gray-100 p-2" style="white-space: pre-wrap; word-break: break-word;">${result.output}</pre>
    </div>
    <div class="flex-1">
      ${missingCurves.length > 0 ? `
    <div class="mb-4">
      <strong>⚠️ Curves Without Data for ${valuationDate}:</strong>
      <ul class="list-disc list-inside">
        ${missingCurves.map(curve => {
              const label = selectedCurves.has(curve) ?
                `${curve} (selected curve)` :
                `${curve} (parent curve)`;
              return `<li>${label}</li>`;
            }).join('')}
      </ul>
    </div>
      ` : ''}
  
      <pre class="bg-gray-100 p-2" style="white-space: pre-wrap; word-break: break-word;">${result.debug}</pre>
    </div>
  </div>
`;
            setTimeout(() => {
              document.getElementById('scenarioOutputContainer')?.scrollIntoView({ behavior: 'smooth' });
            }, 0);
            document.getElementById('backToScenarioBtn')?.addEventListener('click', () => {
              document.getElementById('curveContent')?.scrollIntoView({ behavior: 'smooth' });
            });
          } else {
            curveContent.innerHTML += `<p style="color: red;">⚠️ No scenario output returned.</p>`;
          }

          const msg = document.getElementById('runningMessage');
          if (msg) msg.remove();
        });
    }

    // Trigger scenario form based on shock type selection
    function proceedToScenario() {
      selectedCurvesDiv.style.display = 'none';
      currentShockBy = document.querySelector('input[name="shockBy"]:checked').value;
      const curveTypeShock = document.getElementById('curveTypeSelect').value;

      document.getElementById('curveTypeSection').style.display = currentShockBy === 'type' ? 'block' : 'none';
      document.getElementById('curveNameSection').style.display = currentShockBy === 'name' ? 'block' : 'none';

      if (currentShockBy === 'type') {
        shockByCurveNameSet.clear();
        IRRiskFactors = `3m${curveTypeShock}:6m${curveTypeShock}:1y${curveTypeShock}:2y${curveTypeShock}:3y${curveTypeShock}:5y${curveTypeShock}:7y${curveTypeShock}:10y${curveTypeShock}:20y${curveTypeShock}:30y${curveTypeShock}`;
        renderScenarioForm(curveTypeShock, '', '', '');
        renderGridPointScenarioForm(curveTypeShock, [{
          name: "Curve Type",
          tenors: [`3m${curveTypeShock}`, `6m${curveTypeShock}`, `1y${curveTypeShock}`, `2y${curveTypeShock}`,
          `3y${curveTypeShock}`, `5y${curveTypeShock}`, `7y${curveTypeShock}`, `10y${curveTypeShock}`,
          `20y${curveTypeShock}`, `30y${curveTypeShock}`
          ]
        }]);
      } else if (currentShockBy === 'ALL') {
        shockByCurveNameSet.clear();
      } else {
        renderScenarioForm('Curve Name', '', '', '');
      }
    }

    // Displays scenario form on frontend for user to edit
    function renderScenarioForm(curveName, parentCurveName, childCurveName, tenors) {
      const curveContent = document.getElementById('curveContent');
      const defaultRow = ['BaseCase', curveName, ...Array(10).fill('0')];

      let type = '';
      const shockByText = curveName === 'ALL' ? 'Selected Curves' : curveName;

      // Shock By Curve Name: test if selected curves contains data container
      const curveNameShockDC = containsDataContainer(dataContainerNames, shockByCurveNameSet);

      // Other Shocks (all, curve type): test if user's selected curves contain data container
      const selectedCurvesDC = containsDataContainer(dataContainerNames, selectedCurves);
      if (curveNameShockDC === "all" || selectedCurvesDC === "all") {
        type = 'Data Container';
      }

      let html = `
      <div class="flex items-center justify-between gap-6 mb-4">
    <h3 class="output-heading">Shock By: ${shockByText}</h3>
    <button id="viewOutputBtn" class="text-blue-600 font-bold text-base underline hover:text-blue-800" style="display: none;">
      View Output ↓
    </button>
  </div>
    <div style="display: flex; gap: 80px; margin-top: 10px; margin-bottom: 10px;">
      <div style="display: flex; flex-direction: column; gap: 10px;">
        <label class="label-group" id="irDataTypeContainer">IR Data Type:
          <select id="scenarioIRDataType" class="rounded-dropdown">
            <option value="bps">bps</option>
            <option value="decimal">decimal</option>
          </select>
        </label>
        <label class="label-group" id="irShockTypeContainer">IR Shock Type:
          <select id="scenarioShockType" class="rounded-dropdown">
            <option value="">Rate</option>
            <option value="Spread">Spread</option>
          </select>
        </label>
        <label class="label-group" id="eqDataTypeContainer" style="display: block;">EQ Data Type:
          <select id="scenarioEQDataType" class="rounded-dropdown">
            <option value="decimal">decimal</option>
            <option value="bps">bps</option>
          </select>
        </label>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
          <span style="font-weight: 500;">Greek:</span>
          <span>Off</span>
          <label class="toggle-switch" style="display: flex; align-items: center;">
            <input type="checkbox" id="scenarioGreekToggle" ${dealsManager ? 'checked' : ''}>
            <span class="slider"></span>
          </label>
          <span>On</span>
          <span id="shockAmountDisplay" style="display: none; margin-left: 10px; font-size: 0.9em; color: #555;">
            <span id="shockAmountValue">0.001</span>
          </span>
        </div>
      </div>
      </div>
    </div>
  `;

      html += `
    <div id="gridFormContainer" style="display: block;">
          <p class="text-sm text-gray-600">Select curves from the 'Shock By Curve Name' list to add scenarios.</p>
        </div>`;

      curveContent.innerHTML = html;

      const irDataTypeContainer = document.getElementById('irDataTypeContainer');
      const irShockTypeContainer = document.getElementById('irShockTypeContainer');
      const eqDataTypeContainer = document.getElementById('eqDataTypeContainer');

      // Hide EQ data type selection for shock by curve type
      if (curveName === 'Bond' || curveName === 'YieldCurve' || curveName === 'Surv') {
        document.getElementById('eqDataTypeContainer').style.display = 'none';
      }

      // Display data and shock type selections depending on IR and EQ curves selected
      const containsDC = shockByCurveNameSet.size > 0 ? curveNameShockDC : selectedCurvesDC;
      if (shockByCurveNameSet.size > 0 || curveName === 'ALL') {
        if (containsDC === 'all') {
          irDataTypeContainer.style.display = 'none';
          irShockTypeContainer.style.display = 'none';
          eqDataTypeContainer.style.display = 'block';
        } else if (containsDC === 'some') {
          irDataTypeContainer.style.display = 'block';
          irShockTypeContainer.style.display = 'block';
          eqDataTypeContainer.style.display = 'block';
          document.getElementById('scenarioIRDataType').value = 'decimal';
        } else if (containsDC === 'none') {
          irDataTypeContainer.style.display = 'block';
          irShockTypeContainer.style.display = 'block';
          eqDataTypeContainer.style.display = 'none';
        }
      }

      // Display greek and shock amount depending on data type (bps, decimal) and type of curves selected (IR, EQ)
      const greekToggle = document.getElementById('scenarioGreekToggle');
      const shockAmountDisplay = document.getElementById('shockAmountDisplay');
      const shockAmountValue = document.getElementById('shockAmountValue');
      const irTypeSelect = document.getElementById('scenarioIRDataType');
      const eqTypeSelect = document.getElementById('scenarioEQDataType');

      if (greekToggle) {
        const showShockAmount = () => {
          const greekOn = greekToggle.checked;
          shockAmountDisplay.style.display = greekOn ? 'inline-block' : 'none';
        };

        const updateShockAmount = () => {
          if (shockByCurveNameSet.size > 0 || curveName === 'ALL') {
            if (containsDC === 'some') {
              const IRVal = irTypeSelect.value === 'bps' ? '10 bps' : '0.001';
              const EQVal = eqTypeSelect.value === 'bps' ? '100 bps' : '0.01';
              shockAmountValue.textContent = `IR Shock Amt: ${IRVal}, EQ Shock Amt: ${EQVal}`;
            } else if (containsDC === 'all') {
              shockAmountValue.textContent = eqTypeSelect.value === 'bps' ? 'EQ Shock Amt: 100 bps' : 'EQ Shock Amt: 0.01';
            } else {
              shockAmountValue.textContent = irTypeSelect.value === 'bps' ? 'IR Shock Amt: 10 bps' : 'IR Shock Amt: 0.001';
            }
          } else {
            if (irTypeSelect.value === 'bps') {
              shockAmountValue.textContent = 'IR Shock Amt: 10 bps';
            } else {
              shockAmountValue.textContent = 'IR Shock Amt: 0.001';
            }
          }
        };

        greekToggle.addEventListener('change', showShockAmount);
        irTypeSelect.addEventListener('change', updateShockAmount);
        eqTypeSelect.addEventListener('change', updateShockAmount);

        showShockAmount();
        updateShockAmount();
      }
    }

    // Returns if selectedCurves contain none, some or all data container curves
    function containsDataContainer(dataContainerCurves, selectedCurves) {
      const bArray = [...selectedCurves];
      const all = bArray.every(elem => dataContainerCurves.has(elem));
      const some = bArray.some(elem => dataContainerCurves.has(elem));

      if (all) return "all";
      if (some) return "some";
      return "none";
    }


    // Displays scenario generation form for shock by grid point
    async function renderGridPointScenarioForm(curveName, curves) {
      console.log(curveName);
      const gridForm = document.getElementById('gridFormContainer');
      gridForm.innerHTML = '';

      const container = document.createElement('div');
      container.className = 'mt-4 overflow-x-auto';

      const table = document.createElement('table');
      table.className = 'border border-gray-300 text-sm text-gray-900 rounded-md';
      table.id = 'gridScenarioTable';
      const headerRow = document.createElement('tr');

      // Don't display curve name column for shock by curve type
      if (curveName !== "Bond" && curveName !== "YieldCurve" && curveName !== "Surv") {
        const curveNameHeader = document.createElement('th');
        curveNameHeader.className = 'px-3 py-2 border-r';
        curveNameHeader.innerText = 'Curve Name';
        headerRow.appendChild(curveNameHeader);
      }

      const labelCell = document.createElement('th');
      labelCell.className = 'px-3 py-2 border-r';
      if (curveName === 'ALL') {
        labelCell.innerHTML = `Bucket (IR)<br>Gridpoint (EQ)`;
      } else if (curveName === "Bond" || curveName === "YieldCurve" || curveName === "Surv") {
        labelCell.innerHTML = `Bucket`;
      } else {
        labelCell.innerHTML = `Gridpoint`;
      }
      headerRow.appendChild(labelCell);

      const scenarioNames = ['BaseCase'];
      scenarioNames.forEach((name, index) => {
        const th = document.createElement('th');
        th.className = 'px-3 py-2 border-r align-top text-center';

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'scenario-include-checkbox';
        checkbox.style.marginBottom = '4px';
        checkbox.checked = true; // default to included

        // Create label for scenario name
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = name;
        nameInput.className = 'scenario-name-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center mt-1';

        // Wrap checkbox and input
        const wrapper = document.createElement('div');
        wrapper.className = 'flex flex-col items-center';
        wrapper.appendChild(checkbox);
        wrapper.appendChild(nameInput);
        th.style.whiteSpace = 'nowrap';
        th.style.minWidth = '160px';
        th.style.minWidth = '160px';


        th.appendChild(wrapper);
        headerRow.appendChild(th);
      });

      const thead = document.createElement('thead');
      thead.className = 'bg-gray-50';
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      curves.forEach(curve => {
        curve.tenors.forEach((tenor, index) => {
          const row = document.createElement('tr');

          // Add curve name column if not shock by curve type
          if (curveName !== "Bond" && curveName !== "YieldCurve" && curveName !== "Surv") {
            const labelCell = document.createElement('td');
            labelCell.className = 'px-3 py-2 border-r font-semibold text-gray-800';
            labelCell.innerText = index === 0 ? curve.name : '';
            row.appendChild(labelCell);
          }

          // Gridpoint column
          const tenorCell = document.createElement('td');
          tenorCell.className = 'px-3 py-2 border-r font-medium text-gray-700';
          tenorCell.innerText = tenor;
          row.appendChild(tenorCell);

          // Scenario value columns
          scenarioNames.forEach(() => {
            const td = document.createElement('td');
            td.className = 'px-3 py-2 border-r';
            const input = document.createElement('input');
            input.type = 'number';
            input.value = '0';
            input.className = 'grid-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center';
            td.appendChild(input);
            row.appendChild(td);
          });

          tbody.appendChild(row);
        });
      });

      table.appendChild(tbody);
      container.appendChild(table);

      // Create button container
      const buttonRow = document.createElement('div');
      buttonRow.style.display = 'flex';
      buttonRow.style.alignItems = 'center';
      buttonRow.style.gap = '10px';
      buttonRow.style.marginTop = '15px';

      // Add Scenario button
      const addBtn = document.createElement('button');
      addBtn.id = 'addGridPointBtn';
      addBtn.className = 'green-button';
      addBtn.innerText = 'Add Scenario';

      // Save button
      const saveBtn = document.createElement('button');
      saveBtn.className = 'green-button';
      saveBtn.innerText = 'Save';
      saveBtn.onclick = () => saveGridScenario(curveName);

      // Run button
      const runBtn = document.createElement('button');
      runBtn.className = 'green-button';
      runBtn.innerText = 'Run Scenario';
      runBtn.onclick = () => runSelectedCurves();

      // Add Scenario button logic
      addBtn.onclick = () => {
        const newColIndex = table.rows[0].cells.length - 1;

        const th = document.createElement('th');
        th.className = 'px-3 py-2 border-r align-top text-center';

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'scenario-include-checkbox';
        checkbox.style.marginBottom = '4px';
        checkbox.checked = true;

        // Create scenario name input
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.placeholder = 'GridName';
        nameInput.value = '';
        nameInput.className = 'scenario-name-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center mt-1';

        // Create fill input and button
        const fillWrapper = document.createElement('div');
        fillWrapper.className = 'flex justify-center items-center gap-1 mt-1';

        const fillInput = document.createElement('input');
        fillInput.type = 'number';
        fillInput.placeholder = 'Value';
        fillInput.className = 'w-20 h-7 border border-gray-300 rounded text-sm text-center';
        fillInput.dataset.col = newColIndex;

        const fillButton = document.createElement('button');
        fillButton.className = 'green-button text-xs px-2 py-1';
        fillButton.innerText = 'Fill Column';
        fillButton.dataset.col = newColIndex;
        fillButton.onclick = () => {
          const value = fillInput.value;
          const colIndex = parseInt(fillInput.dataset.col, 10);
          const inputs = table.querySelectorAll(`tbody tr td:nth-child(${colIndex + 2}) input`);
          inputs.forEach(input => input.value = value);
        };

        fillWrapper.appendChild(fillInput);
        fillWrapper.appendChild(fillButton);

        // Wrap checkbox and input
        const wrapper = document.createElement('div');
        wrapper.className = 'flex flex-col items-center';
        wrapper.appendChild(checkbox);
        wrapper.appendChild(nameInput);
        wrapper.appendChild(fillWrapper);

        th.appendChild(wrapper);
        table.rows[0].appendChild(th);

        // Add cells to each row
        for (let i = 1; i < table.rows.length; i++) {
          const td = document.createElement('td');
          td.className = 'px-3 py-2 border-r';
          const input = document.createElement('input');
          input.type = 'number';
          input.value = '0';
          input.className = 'grid-input w-full px-2 py-1 border border-gray-300 rounded text-sm text-center';
          td.appendChild(input);
          table.rows[i].appendChild(td);
        }
      };

      // Click save message
      const message = document.createElement('p');
      message.style.color = 'red';
      message.style.marginLeft = '6px';
      message.style.marginTop = '10px';
      message.style.fontSize = "0.9em";
      message.innerText = '(Click save before running)';

      gridForm.appendChild(message);

      // Append buttons to container
      buttonRow.appendChild(addBtn);
      buttonRow.appendChild(saveBtn);

      if (!dealsManager) {
        buttonRow.appendChild(runBtn);
      }
      buttonRow.appendChild(message);

      // Append buttons to the grid form
      gridForm.appendChild(buttonRow);

      // Placeholder for the "Running..." message
      const runningMsg = document.createElement('p');
      runningMsg.id = 'runningMessage';
      runningMsg.style.color = 'green';
      runningMsg.style.marginTop = '10px';
      runningMsg.style.fontSize = '0.95em';
      gridForm.appendChild(runningMsg);

      const viewScenario = document.createElement('div');
      viewScenario.id = 'gridLinkContainer';
      viewScenario.style.marginTop = '4px';
      gridForm.appendChild(viewScenario);

      // Fill column buttons
      const fillRow = document.createElement('div');
      fillRow.className = 'ml-8 mt-2 flex gap-4';
      gridForm.appendChild(fillRow);
      gridForm.appendChild(container);

      // Output container for scenario results
      const outputContainer = document.createElement('div');
      outputContainer.id = 'scenarioOutputContainer';
      outputContainer.className = 'mt-8';
      gridForm.appendChild(outputContainer);
    }


    function fillGridInputs() {
      const value = document.getElementById('fillValue').value;
      document.querySelectorAll('.grid-input').forEach(input => {
        input.value = value;
      });
    }


    function addGridPointRow(curveName, tenors) {
      const tbody = document.getElementById('gridScenarioTable').querySelector('tbody');
      const row = document.createElement('tr');
      row.innerHTML = `
    <td class="px-3 py-2 border-r">
      <input type="text" name="GridName" placeholder="GridName" class="w-full px-2 py-1 border rounded text-sm" />
    </td>
    ${tenors.map(() => `
      <td class="px-3 py-2 border-r">
        <input type="number" value="0" class="w-full px-2 py-1 border rounded text-sm text-center" />
      </td>`).join('')}
    <td class="px-3 py-2 border-l border-gray-200" style="min-width: 120px;">
      <div class="flex items-center gap-2">
        <input type="number" placeholder="Enter Value" class="fill-value-input w-auto px-2.5 py-1 bg-gray-200 border border-gray-300 rounded text-sm text-center" />
        <button onclick="fillRowWithValue(this)" class="px-2.5 py-1.5 text-white rounded text-sm" style="background-color: #2563eb;">Fill Row</button>
      </div>
    </td>
  `;
      tbody.appendChild(row);
    }

    // Saving scenario definition file for grid point shock
    function saveGridScenario(curveName) {
      let type = '';
      if (containsDataContainer(dataContainerNames, shockByCurveNameSet) === "all") {
        type = 'Data Container';
      }

      // Determine if selected curves contain data container curves
      let containsDC = '';
      const isCurveType = (curveName === "Bond" || curveName === "YieldCurve" || curveName === "Surv");
      if (isCurveType) {
        containsDC = 'none';
      } else if (shockByCurveNameSet.size > 0) {
        containsDC = containsDataContainer(dataContainerNames, shockByCurveNameSet);
      } else {
        containsDC = containsDataContainer(dataContainerNames, selectedCurves);
      }

      const table = document.getElementById('gridScenarioTable');

      // Only write scenarios to scenario def file if they are checked by user
      const headerCells = table.querySelectorAll('thead th');
      const includedScenarios = [];

      headerCells.forEach((th, index) => {
        const checkbox = th.querySelector('.scenario-include-checkbox');
        const nameInput = th.querySelector('.scenario-name-input');
        if (checkbox && checkbox.checked && nameInput) {
          includedScenarios.push({
            name: nameInput.value.trim(),
            colIndex: index
          });
        }
      });

      const tbodyRows = Array.from(table.querySelectorAll('tbody tr'));
      const tenorLabels = tbodyRows.map(row => {
        const cells = row.querySelectorAll('td');
        return cells[isCurveType ? 0 : 1].innerText.trim();
      });


      const rows = [];
      includedScenarios.forEach(({ name, colIndex }) => {
        const values = [];
        for (let j = 0; j < tenorLabels.length; j++) {
          const row = table.querySelectorAll('tbody tr')[j];
          const cell = row.querySelectorAll('td')[colIndex];
          const input = cell.querySelector('input');
          values.push(input?.value.trim() || '0');
        }
        rows.push({
          GridName: name,
          CurveName: isCurveType ? curveName : '', // only include CurveName for shock by curve type
          values
        });
      });

      const scenario = {
        curveName,
        IRDataType: document.getElementById('scenarioIRDataType')?.value || 'decimal',
        IRShockType: document.getElementById('scenarioShockType')?.value || '',
        EQDataType: document.getElementById('scenarioEQDataType')?.value,
        Greek: !document.getElementById('scenarioGreekToggle')?.checked ? false : true,
        containsDC,
        IRRiskFactors,
        EQRiskFactors,
        tenors: tenorLabels,
        rows
      };
      console.log(scenario);

      fetch(`/api/scenario-generation/save-scenario-def?type=${encodeURIComponent(type)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(scenario)
      })
        .then(res => res.json())
        .then(data => {
          alert(data.message);
          scenarioSaved = true;
          const linkContainer = document.getElementById('gridLinkContainer');
          linkContainer.innerHTML = `
        <a href="/api/scenario-generation/scenario.txt" target="_blank" rel="noopener noreferrer"><u>View Scenario File</u></a><br/>
      `;
        })
        .catch(err => {
          console.error('❌ Failed to save scenario:', err);
          alert('Failed to save scenario.');
        });
    }
  </script>
</body>

</html>